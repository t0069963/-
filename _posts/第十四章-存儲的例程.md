## 目標 
完成本課後，您應該能夠： 
• 定義存儲例程 
• 區分存儲過程和存儲函數 
• 創建和執行存儲例程 
• 管理數據庫中的存儲例程 
• 在存儲例程中分配變量 
• 使用游標和流控制 語句 
• 列出存儲例程的限制

## 議程 
• 存儲例程概述 
• 創建存儲例程 
• 存儲例程中的變量 
• 存儲例程中的參數 
• 管理數據庫中的存儲例程 
• 使用流控制語句和構造 
• 使用游標 
• 存儲例程的限制

## 什麼是存儲例程？
存儲例程是一組存儲在服務器上的 SQL 語句。
• 客戶端按名稱執行存儲的例程，而不是每次都發出單獨的語句。
•有兩種類型的存儲例程： 
– 存儲過程：作為語句執行但不返回值的一系列指令。 使用 CALL 語句調用過程，該過程可選擇使用輸出變量傳回值。
– 存儲函數：存儲函數：作為表達式執行並返回單個值的
一系列指令。 像任何其他函數一樣從語句內部調用函數（即通過調用函數的名稱），它返回一個標量值。

## 存儲例程的使用 
存儲例程用於： 
• 簡化應用程序設計 
– 所有數據相關操作的單點開發 
– 用於訪問和修改數據的標準語言 (SQL) – 通用數據庫功能的中央 API 
• 提高應用程序安全性 
– 單一 數據功能的安全模型
——安全數據在傳輸前的集中處理 
• 改進
——數據傳輸前的集中選擇和過濾存儲例程的使用 存儲例程用於： 
• 簡化應用程序設計 
– 所有數據相關操作的單點開發 
– 用於訪問和修改數據的標準語言 (SQL) – 通用數據庫功能的中央 API • 提高應用程序安全性 
– 單一 數據功能的安全模型
——安全數據在傳輸前的集中處理 
• 改進
——數據傳輸前的集中選擇和過濾
```
簡化的應用程序設計 存儲例程使您能夠在一個應用程序 (MySQL) 中創建語句，該語句可
用於使用不同編程語言或在不同平台上工作的多個客戶端應用程序。
• 一個應用程序：當您將存儲例程用於業務邏輯時，您無需在訪問數據的程序中編寫相同的邏輯。 您的代碼更易於維護，因為它集中在一個數據庫和平台 (MySQL) 上。 如果存儲的例程包含驗證邏輯，它們有助於最大限度地減少來自不驗證數據的外部系統的數據損壞的可能性。 當客戶端應用程序由第三方維護時，這一點尤其重要。應用程序由第三方維護。
• 一種編程語言：通過在 MySQL 中使用存儲例程，您可以僅使用一種編程語言在一個位置編寫數據訪問邏輯。 這最大限度地減少了程序的開發、實施和維護，並提供了最高級別的數據驗證和質量保證，無論哪個應用程序訪問數據。
• 函數庫：您可以在數據庫服務器上創建存儲例程庫。
這些例程然後充當數據庫的 API，並且可以被應用程序用作數據、驗證和業務邏輯的簡化接口
安全性 
存儲例程提供了高級別的安全性。 您可以確保應用程序和用戶無法直接訪問數據庫表，而只能執行特定的存儲例程。
可以記錄所有操作。 可以記錄所有操作。
• 最少的數據訪問：通過存儲例程，最終用戶可以盡可能少地訪問數據以完成他們的任務。
• 單一位置處理：通過存儲例程，數據庫服務器可以直接訪問它需要操作的數據，並且只需要將最終結果發送回用戶。 這消除了在處理過程中大量數據可能被外部或內部來源監控的風險。 只有數據的最終結果集是改進的性能 存儲例程提供了改進的性能，因為服務器和客戶端之間需要發送的信息更少。 此外，每個連接在第一次調用時緩存每個存儲過程的優化版本，這加快了對該連接上相同過程的後續調用
```

 ## 存儲例程的問題 
• 增加服務器負載：在數據庫中執行存儲例程可能會增加服務器負載並降低應用程序的性能。
• 有限的開發工具：目前在MySQL 中開發存儲例程的開發工具很少，用於在MySQL 中開發存儲例程的開發工具。
• 有限的調試/分析功能：此限制會使編寫和調試存儲例程更加困難，應在設計階段加以考慮。
• 有限的語言功能和速度：儘管MySQL 中的例程具有無與倫比的數據訪問能力，但許多其他編程語言更快、更通用，具有更廣泛的功能。

## 存儲例程的問題 
• 增加服務器負載：在數據庫中執行存儲例程可能會增加服務器負載並降低應用程序的性能。
• 有限的開發工具：目前在MySQL 中開發存儲例程的開發工具很少，用於在MySQL 中開發存儲例程的開發工具。
• 有限的調試/分析功能：此限制會使編寫和調試存儲例程更加困難，應在設計階段加以考慮。
• 有限的語言功能和速度：儘管MySQL 中的沒有例程具有無與倫比的數據訪問能力，但許多其他編程語言更快、更通用，具有更廣泛的功能。創建存儲過程 • 創建存儲過程的基本語法是：

## 創建存儲過程 
• 創建存儲過程的基本語法是：
CREATE PROCEDURE <procedure_name>
<procedure_statements>
• 以下是具有單個語句的過程示例：
mysql> CREATE PROCEDURE world_country_count () -> SELECT 'Country Count', COUNT(*) FROM Country;
• 使用 CALL 語句執行存儲過程：
mysql> CALL world_country_count;
![[Pasted image 20211220113100.png]]
```
幻燈片示例中的存儲過程只是計算世界數據庫 Country 表中的行數。
```

## 創建存儲函數
• 創建存儲函數的基本語法是：
CREATE FUNCTION <function_name> RETURNS <return_type> <function_statements>

• 以下是一個存儲函數示例，它採用單參數，使用內置 SQL 函數執行操作，並返回結果：
mysql> CREATE FUNCTIONThankYou(s CHAR(20)) -> RETURNS CHAR(50) -> RETURN CONCAT('Thank you, ', s, '!');
• 按名稱調用函數：
mysql> SELECTThankYou('Michael');
![[Pasted image 20211220113705.png]]
```
每個存儲的函數都返回一個在另一個語句或表達式的主體中使用的值； 存儲過程沒有。 在存儲函數中使用 RETURNS 關鍵字標識返回值的數據類型，並使用 RETURN 關鍵字指定實際價值
```

## 存儲例程中的複合語句
MySQL 中的大多數存儲例程都需要多行代碼。
• 使用語法BEGIN…END 將多個語句括在存儲例程中。
• 在BEGIN…END 塊中，語句必須以“ 和分號“;”結束。
• 在使用mysql 命令行客戶端或批處理時使用DELIMITER 語句。 例如：
DELIMITER // ...
DELIMITER；
• 您可以嵌套和標記BEGIN … END 塊。
```
在存儲的例程和触發器中使用 BEGIN ... END。  BEGIN ... END 塊包含零個或多個語句。 空複合語句是合法的，語句數沒有上限。
幻燈片中的第一個 DELIMITER 語句將 SQL 語句終止符號更改為兩個正斜杠“//”。 這允許存儲的例程內容以分號“;”終止 而不終止存儲例程的創建。 第二個 DELIMITER 語句將終止 SQL 字符返回到分號“;”。
您可以選擇任何分隔符或字符序列，但要避免 SQL 語法中使用的反斜杠和其他符號。
DELIMITER 不會更改所有語句終止符。 因為\G 是MySQL 的客戶端命令，所以它不會被DELIMITER 語句更改。 因此，您不能在復合語句中使用 \G。
```

## 複合語句：示例
```
mysql> DELIMITER //
mysql> CREATE PROCEDURE world_record_count ()
-> BEGIN
-> SELECT 'country count ', COUNT(*) FROM country;
-> SELECT 'cit co nt ' COUNT(*) FROM cit SELECT 'city count ', COUNT(*) FROM city;
-> SELECT 'CountryLanguage count', COUNT(*) FROM CountryLanguage;
-> END//
mysql> DELIMITER ;
```
```
幻燈片中的第一個 DELIMITER 語句將分隔符從標準分號更改為 //。  mysql 命令行客戶端在您輸入 // 之前不會提交語句供服務器處理，這允許您輸入多個由 Copyright
BEGIN...BLOCK 中的分號沒有服務器嘗試處理它們。 將存儲過程的代碼提交到服務器後，將分隔符改回標準分號。
```

## 本地和用戶變量
局部變量和用戶變量之間有一些主要區別：
• 必須顯式聲明局部變量，而不是用戶變量。
• 局部變量對於例程實例是局部的，而用戶變量對於會話中的所有語句是全局的聲明聲明

## 聲明聲明
使用 DECLARE 語句在存儲例程中聲明局部變量並初始化用戶變量。 例如：
DECLARE tax_rate FLOAT (3,2) DEFAULT 0.07;
• DEFAULT 子句標識變量的初始值。
DECLARE tax_rate FLOAT (3,2) DEFAULT 0.07; 
• 如果沒有DEFAULT 子句，用戶變量的初始值為NULL。變量名的優先規則

## 變量名的優先規則
在此示例中，標識符 param1 和 var1 不明確。
在這種情況下，以下優先規則適用： 
• 例程參數優先於表列。
• 局部變量優先於例程參數或列。
• 內部塊中的局部變量優先於外部塊中的局部變量。
```
mysql> DELIMITER //
mysql> CREATE PROCEDURE precedence (param1 INTEGER)
-> BEGIN
-> DECLARE > DECLARE var1 INT DEFAULT 0; INT DEFAULT 0;
-> SELECT 'outer1', param1, var1;
-> BEGIN
-> DECLARE param1, var1 CHAR(3) DEFAULT 'abc';
-> SELECT 'inner1', param1, var1;
-> END;
-> SELECT 'outer1', param1, var1;
-> END//
mysql> DELIMITER ;
```
```
您可以對例程參數、局部變量和表列使用相同的標識符。
此外，您可以在嵌套塊中使用相同的局部變量名稱，如幻燈片示例所示。  MySQL 使用優先規則來定義不明確變量的範圍。
這種令人困惑和不好的做法。 為不同類型的變量使用不同的前綴以避免名稱衝突。 例如，對參數使用 p_val，對局部變量使用 l_val
```

## 使用 SELECT...INTO
SELECT…INTO 語法將查詢結果存儲在用戶定義的變量中。 這些用戶定義的變量可以是全局的或局部的。
• 會話變量示例：
```
SELECT SUM(population) FROM Country INTO @WorldPop;
SELECT SUM(population) INTO @WorldPop FROM Country;
```
– 無需事先聲明即可使用
• 局部變量示例：
```
SELECT COUNT(*) FROM City INTO TotalCities;
SELECT COUNT(*) INTO TotalCities FROM City;
```
– 使用前必須聲明
```
這種方法對於從存儲的函數中返回查詢結果很有用。 存儲函數無法返回結果集，因此： • 使用 SELECT...INTO 從存儲函數中檢索查詢結果並存儲他們在一個變量中 • 返回變量
```

## 使用 SET 為變量賦值
• SET 語句允許您使用= 或:= 作為賦值運算符為用戶定義的變量賦值。
例如：
```
mysql> DELIMITER //
mysql> CREATE FUNCTION final_bill (total_charge 
-> FLOAT(9,2),
-> tax_rate FLOAT (3,2))
-> RETURNS FLOAT(10,2)
-> BEGIN
-> DECLARE Bill FLOAT(10,2);
-> SET Bill=total_charge + total_charge * tax_rate;
-> RETURN Bill;
> END//
• You can assign values to multiple user variables in the same 
SET statement by separating each variable assignment by a 
comma.
-> END//
mysql> DELIMITER ;
```

## 參數聲明
存儲的例程包括允許您將值傳遞給例程的參數聲明。
• 存儲過程接受 IN、OUT 或 INOUT 參數。
– IN 表示從調用者傳入過程調用者到過程的輸入參數。
– OUT 表示一個輸出參數，該參數具有由過程設置的值，並且在過程終止後可供調用它的進程使用。
– INOUT 表示同時作為 IN 和 OUT 參數的參數。
• 存儲函數將所有參數視為IN 參數。
不要將 IN、OUT 或 INOUT 與存儲的函數一起使用。

## 參數聲明語法
• IN 參數：
```
CREATE PROCEDURE <procedure_name> (IN <parameter_name><parameter_type>)
<procedure_statement>
```
– 如果沒有提供，這是默認參數類型。
— 對 IN 參數值的任何更改對都是不可見的對調用程序來說對 IN 參數值的任何更改都是不可見的。
• 輸出參數：
```
CREATE PROCEDURE <procedure_name> (OUT <parameter_name><parameter_type>)
<procedure_statement>
```
– 初始值為NULL； 返回值對調用者可見。
• INOUT 參數：
```
CREATE PROCEDURE <procedure_name> (INOUT <parameter_name><parameter_type>)
<procedure_statement>
```
– 存儲過程可以修改 INOUT 參數並將新值傳遞回調用程序。
```
IN 參數將值傳遞給過程。 該過程可能會修改該值，但當該過程返回時，調用者看不到該修改。  OUT 參數將值從過程傳遞回調用者，其初始值為 NULL。
過程，當過程返回時，它的值對調用者是可見的。  INOUT 參數由調用者初始化，可由過程修改，當過程返回時，過程所做的任何更改對調用者都是可見的。
```

## 數據庫中的存儲例程
每個存儲的常式都屬於一個特定的資料庫。 這有幾個含義：
•當調用常式時，它執行一個隱式USE語句，該語句在常式終止時撤銷。 在存儲常式中不能有USE語句在存儲常式中不能有USE語句。
•使用資料庫名稱限定常式名稱，以引用不在當前資料庫中的常式。
–例如，要調用測試資料庫中的存儲過程，請使用CALL test。 p（）。
–要選擇函數值要選擇t es資料庫use database中函數f的值，請使用select test。 f（）。
•删除資料庫時，會隱式删除與資料庫關聯的所有存儲常式。

## 檢查存儲例程 
您可以通過三種方式檢查存儲例程： 
• SHOW CREATE PROCEDURE 和 SHOW CREATE FUNCTION 返回用於重新創建命名例程的字符串。
• SHOW PROCEDURE STATUS 和SHOW FUNCTION STATUS 例程的特徵，例如數據庫、名稱、類型、創建者、創建和修改日期。
• INFORMATION_SCHEMA.ROUTINES 表提供有關存儲例程（過程和函數）的信息，並返回在 SHOW CREATE SHOW CREATE... 和 SHOW STATUS SHOW...STATUS stt ta 中找到的大部分詳細信息，包括語法 用於創建存儲的例程。
```
在發出 SHOW CREATE ... 之前，您必須知道例程的名稱以及它是過程還是函數。SHOW…STATUS 語句顯示基於 LIKE 模式或 WHERE 子句的例程。SHOW…STATUS 語句顯示基於 LIKE 模式或 WHERE 子句的例程。如果您不提供模式或 WHERE 條件，則該語句將顯示所有存儲過程或所有存儲函數的信息，具體取決於所使用的語句。 這些語句不顯示例程的實際語法
```


## 刪除存儲例程
• 要刪除現有存儲過程，請使用 DROP PROCEDURE <procedure_name>。
• 要刪除現有的存儲函數，請使用DROP FUNCTION <function_name>。
•如果您不確定存儲例程是否存在，請將IF EXISTS 子句放在<procedure_name> 或<function_name> 之前。 例如：
mysql> DROP PROCEDURE proc_1;
mysql> DROP FUNCTION IF EXISTS func_1;

## 流控制語句 
• 流控制語句控制在代碼中執行操作的順序。
• 兩種常見的流控制是： 
– 選擇：在特定條件下遵守的語句。
在 MySQL 中，這些用 In MySQL 表示，這些用 IF 和 CASE 語句表示。
– 循環：重複遵守的語句。 在 MySQL 中，這些用 REPEAT、WHILE 和 LOOP 語句表示。
```高級編程語言具有使您能夠控制執行流程的語句。  MySQL 還提供了流控制語句，允許您控制存儲例程中的程序流
```

## IF 語句 
• 是最基本的條件結構 
• 由 END IF 終止
• 可以在 ELSEIF 和 ELSE 語句中包含可選的語句塊
```
IF (<test_condition>) THEN
...
ELSEIF (<test_condition>) THEN
...
ELSE
...
END IF;
```

## CASE 語句：Simple Case 
一個簡單的 case 使用 CASE 語句將已知值與其他值進行比較：
```
CASE <case_value>
WHEN <when_value1> THEN
...
WHEN <when_value2> THEN
...
ELSE
...
END CASE
```
 • <case_value> 與一組其他值的相等性進行比較。
 • 如果沒有<when_value> 與提供的<case_value> 匹配，則CASE 語句執行ELSE 塊的內容。
 
 ## CASE 聲明：搜索到的案例
 搜索到的案例使用 CASE 語句根據條件執行代碼：
 ```
 CASE
WHEN <test_condition1> THEN
 ...
WHEN <test_condition2> THEN
...
ELSE
...
END CASE
```
• 執行條件返回 true 的第一個代碼塊 
• 如果所有條件都返回 false，則執行 ELSE 塊

## REPEAT 語句 
• 重複 SQL 語句塊，直到測試條件為真 • 始終至少執行一次
```
REPEAT
...
UNTIL <test_condition>
END REPEAT;

```
• 可以選擇包含標籤
```
REPEAT
• Can optionally include a label
...
UNTIL <test_condition>
END REPEAT;

```
```
REPEAT 語句可以選擇包含一個標籤，如幻燈片所示。 標籤是使用冒號 (:) 附加到語句的標識符。 使用標籤來識別嵌套的 REPEAT 循環。 REPEAT 語句可以在 REPEAT 語句的開頭和結尾使用標籤。結束標籤是可選的，但如果存在，它必須與開始標籤匹配
```

## WHILE 語句
WHILE 語句：
```
WHILE <test_condition> DO
...
END WHILE
```
• 包含一個重複的代碼塊 
• 包含一個重複的代碼塊，只要 <test_condition> 為真 • 如果測試條件返回 false 則不執行代碼塊 
• 支持標籤
```
mylabel: WHILE <test_condition> DO
... 
END WHILE mylabel
```

## 離開並迭代
MySQL 提供了兩個在循環內運行並支持標籤的控制語句： 
• LEAVE：該語句退出任何帶標籤的流控制結構，例如 LOOP、REPEAT 或 WHILE。  LEAVE 也可用於帶標籤的 BEGIN END BEGIN…END 塊。
• ITERATE：此語句將控制返回到循環構造的開頭，就像重新啟動它一樣。 如果您為 ITERATE 語句提供標籤，它會將控制權返回到帶標籤的循環的開頭。
```
LEAVE 和 ITERATE 可以跳轉到任何標籤名稱，而不僅僅是包含 LOOP 的標籤名稱。
```

## 游標
• 游標是存儲例程中的控制結構，可一次檢索一行記錄。
• 在循環中使用游標，在循環的每次迭代中獲取和處理一行。

## 聲明游標
使用以下語法聲明游標：
DECLARE <cursor_name> CURSOR FOR <select_statement>;
• 必須在聲明游標之前聲明變量和條件。
DECLARE <cursor_name> CURSOR FOR <select_statement>; 
• 在復合語句中聲明游標時，游標的範圍僅限於復合語句。
• 如果在單個塊中聲明多個游標，則塊中的每個游標必須具有唯一的名稱。
```
當您循環到游標的末尾時，MySQL 會引發一個帶有 SQLSTATE '02000' 的事件。 使用 CONTINUE HANDLER 處理此事件以識別您的光標已到達末尾，如以下示例所示：
DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 'yes'
```

## 使用游標 
您可以打開游標、從中獲取行和關閉游標： 
• OPEN：打開先前聲明的游標：
```
OPEN <cursor_name>;
```
• FETCH：從 OPEN <cursor_name> 中讀取一個或多個列的下一行； 打開游標，將每個游標列分配給它自己的變量，並推進游標指針：
```
FETCH <cursor_name> INTO <var_name1>, 
<var_name2> ...
```
• CLOSE：顯式關閉游標：
CLOSE <cursor_name>; 
• 如果您獲取越過游標的末尾，MySQL 會給出錯誤。
• MySQL 在聲明游標的塊的末尾關閉所有尚未顯式關閉的游標。

## 使用光標：示例
```
01 DELIMITER //
02 CREATE PROCEDURE populous_countries()
03 BEGIN
04 DECLARE done INT DEFAULT FALSE;
05 DECLARE t_name CHAR(52);
06 DECLARE t_pop INT;
07 DECLARE cur CURSOR FOR SELECT Name, Population FROM world.Country;
08 DECLARE CONTINUE HANDLER F HANDLER FOR NOT FOUND SET done = TRUE;
09
10 OPEN cur;
11
12 read_loop: LOOP
13 FETCH cur INTO t_name, t_pop;
14 IF done THEN
15 LEAVE read_loop;
16 END IF;
17 IF t_pop > 100000000 THEN
18 INSERT INTO ld Bi P VALUES (t t ) INSERT INTO world.BigPop VALUES (t_name, t_pop);
19 END IF;
20 END LOOP;
21
22 CLOSE cur;
23 END//
24 DELIMITER ;
```
```
幻燈片中的存儲過程示例演示瞭如何使用游標處理 Country 表中的每一行，並將 Population 值大於 1 億的任何國家寫入名為 BigPop 的新表中。
• 第 1 行將標準分號分隔符替換為 //。
• 第 2 行創建名為 populous_countries 的存儲過程，沒有參數。
• 第 3 行開始代碼塊。
• 第 4 行創建了一個名為 done 的變量，其初始值為 FALSE，用於檢查 Country 表的結尾。
• 第 5 行和第 6 行聲明本地用戶變量以存儲每行的國家/地區 pp 名稱和人口值。
• 第 7 行基於 Country 表的 SELECT 創建一個游標，該表檢索每個國家/地區的 Name 和 Population 列值。
• 第 8 行聲明了一個條件處理程序，它響應以 02 開頭的 SQLState 錯誤。（NOT FOUND 子句代表所有此類錯誤。）當沒有要讀取的數據時會引發這些錯誤。 如果存儲過程引發了這樣的錯誤，則將 done 變量的值設置為 TRUE。
• 第 10 行打開游標，然後讀取 Country 表並將游標內容設置為查詢檢索的第一行
• 第 12 行開始一個 LOOP，它重複第 13 行和第 20 行 END LOOP 語句之間的代碼。
• 第 13 行使用 FETCH...INTO 將游標內容分別存儲在本地用戶變量 t_name 和 t_pop 中。
• 第 14 行檢查完成標誌的狀態。 如果為 TRUE，則表示條件處理程序收到了以 02 開頭的 SQLState 錯誤，這意味著沒有更多行可供游標讀取，並在第 15 行退出循環。
• 在第 17 行，存儲過程檢查包含當前行的 Population 值的 t_pop 變量的值。 如果該值大於 1 億，則將分別存儲在 t_name 和 t_pop 中的 Name 和 Population 值寫入 BigPop 表。
• 在第 22 行，存儲過程關閉游標。
• 在第 23 行，存儲過程代碼終止。
• 第 24 行將分隔符恢復為標準分號
```

## 游標的限制 
• 游標是只讀的。 它們不能用於更新行。
• MySQL 沒有實現語法UPDATE WHERE CURRENT OF 和DELETE WHERE CURRENT OF，因為服務器不支持可更新游標。
• 游標不敏感：服務器可能會也可能不會復制其結果表。
• 光標不可滾動。 您必須從頭到尾依次獲取每一行，不能跳過任何行。
• 準備好的語句最多可以包含一個游標。 如果需要多個游標，則必須準備多個語句。
• 不能為使用 PREPARE 和 EXECUTE 創建的動態語句聲明游標，例如 CHECK TABLES、HANDLER READ 和 SHOW BINLOG EVENTS。

## 存儲例程的限制 
並非所有存儲例程（存儲過程和存儲函數）中都允許使用以下語句： 
• 準備好的語句中不允許的任何語句 
– 除了 SIGNAL、RESIGNAL 和 GET DIAGNOSTICS 
• ALTER VIEW 
• LOAD DATA 和 LOAD TABLE 
• INSERT DELAYED 其他限制包括： 
• 存儲例程執行的準備語句不能 存儲例程執行的準備語句不能引用該存儲例程中的局部變量。
• 要在存儲例程中顯式啟動新事務，您必須使用 START TRANSACTION
```
此幻燈片中列出的一些陳述未包含在本課程中，但為了完整性而包括在內。  MySQL 參考手冊描述了它們的功能和用途。
由於局部變量僅在存儲程序執行期間在作用域內，您不能參考
由於局部變量僅在存儲程序執行期間才在作用域內，因此您不能在存儲程序中創建的準備好的語句中引用它們。 例如，您不能將 SELECT ... INTO <local_var> 用作存儲過程中的準備語句。 此限制也適用於存儲過程和函數參數。
插入不能延遲。 接受 INSERT DELAYED 語法，但該語句作為普通 INSERT 處理。
在所有存儲程序（存儲過程和函數、觸發器和事件）中，解析器將 BEGIN 關鍵字視為 BEGIN…END 塊的開始。 要在存儲過程中開始事務，請改用 START TRANSACTION。
```

## 存儲函數的限制 
除了存儲過程的一般限制外，以下限制也適用於存儲函數： 
• 不允許使用以下語句： 
– 導致隱式或顯式回滾的語句 – 不允許返回結果集的語句：  
— 通過使用 SELECT INTO```...<var>``` 或游標和 FETCH 語句來處理函數內的結果集。
– HANDLER...READ 語句 
• 存儲函數不能修改調用它的語句正在使用的表。
• 不能使用多個別名來引用臨時表。
• 不能遞歸使用存儲的函數
```
幻燈片引用的語句在存儲的函數中是不允許的。 它們在存儲過程中是允許的，但從存儲函數（或觸發器）中調用的存儲過程除外——請參閱標題為“觸發器和計劃事件”的課程了解更多
信息）。
```

## 小結 
在本課中，您應該已經學會瞭如何： 
• 定義存儲例程 
• 區分存儲過程和存儲函數 
• 創建和執行存儲例程
• 管理數據庫中的存儲例程 
• 在存儲例程中分配變量
• 使用游標和流控制 語句 
• 列出存儲例程的限制
	
	