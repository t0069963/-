## 目標 
完成本課後，您應該能夠： 
• 描述可用於優化查詢的策略 • 描述查詢優化器的作用
• 使用 EXPLAIN 語句預測查詢性能 • 使用索引進行優化
• 描述 MySQL Enterprise Monitor 的作用 在查詢優化中

## 議程 
• 優化策略 
• MySQL 查詢優化器 
• 索引 
• 使用 EXPLAIN 語句進行查詢分析 • 重寫查詢 
• MySQL Enterprise Monitor

## 為什麼要優化？
優化涉及提高數據庫服務器和針對它運行的查詢的性能。
• 優化減少了查詢執行時間。
• 優化的查詢使使用服務器的每個人都受益。
– 查詢運行得越快，釋放表鎖的速度就越快，允許其他客戶端執行並減少查詢積壓的機會。
• 當服務器運行更流暢，以更少的工作處理更多的查詢時，它的整體性能會更好

## 優化策略
• 創建適當的索引。
• 重寫問題查詢。
• 使用EXPLAIN 語句調查優化機會。
• 考慮替代數據和應用程序設計。
• 考慮替代存儲引擎中可用的功能
```
索引 
減少表查找時間的最好方法是適當地索引你的表。 添加有效索引允許 MySQL 僅讀取表的相關部分，這樣會更快有效的索引允許 MySQL 只讀取表的相關部分，這比查詢和數據修改的全表掃描更快，磁盤密集度更低。
語句受益於在其 JOIN 或 WHERE 子句中使用索引列。
查詢重寫 
您編寫查詢的方式可能會阻止優化器使用索引，即使它可用。 重寫查詢可以讓優化器更有效地使用索引和處理查詢。
EXPLAIN 語句 
EXPLAIN 語句顯示優化器如何處理語句。 使用 EXPLAIN 深入了解如何提高查詢的性能。 例如，EXPLAIN 可以幫助確認您懷疑沒有正確使用索引。
數據和應用程序設計 
您有時可以通過使用不同的方法來提高查詢性能。 例如，您可以生成和維護匯總表，而不是從原始表數據中重複選擇。 表數據。
存儲引擎 
當您選擇具有最符合應用程序要求的屬性的存儲引擎時，查詢會更有效地運行
```

## SQL Parser 和 Query Optimizer 
服務器使用兩層處理模型執行語句，如下圖所示：
![[Pasted image 20211217135532.png]]
```
幻燈片中的圖表顯示了兩層： 
• 上層包括 SQL 解析器和優化器。
• 較低層包含一組存儲引擎，其中包括默認的 InnoDB下層包含一組存儲引擎，包括默認的 InnoDB。
無論使用什麼存儲引擎，大多數 SQL 語句的操作方式都相同：所有常用的 SQL 命令都獨立於存儲引擎。 服務器解析每個語句以查看它是哪種請求，然後使用其優化器來確定如何以最有效的方式執行該語句。  SQL 層不直接與語句命名的表交互。 優化器可能需要根據存儲引擎做出不同的選擇，但這都是通過每個存儲引擎支持的標準化接口 (API) 來處理的。
在大多數情況下，SQL 層不依賴於哪個存儲引擎管理任何給定的表。 這意味著客戶端通常不需要關心哪些引擎參與處理 SQL 語句，並且可以使用相同的 SQL 訪問和操作表，而不管管理它們的引擎。

SQL 語句的這種獨立於引擎的例外情況包括： • CREATE TABLE 有一個 ENGINE 選項，如果您不想使用默認的 InnoDB，您可以使用該選項指定在每個表的基礎上使用哪個存儲引擎。  ALTER TABLE 有一個 ENGINE 選項，使您能夠將表轉換為使用不同的存儲引擎。
• COMMIT 和 ROLLBACK 僅影響由事務存儲引擎（例如 InnoDB）管理的表。
以下屬性取決於存儲引擎： 
• 存儲介質：每個引擎都有自己的存儲表數據的方法。
• 事務能力：事務能力：某些存儲引擎支持事務處理某些存儲引擎支持事務處理以維護數據庫完整性。 請參閱標題為“交易”的課程。  
• 鎖定：每個存儲引擎負責限制多用戶環境中對資源的訪問。
• 備份和恢復：可用的備份技術因存儲引擎而異。
• 優化：在優化由該引擎管理的數據的存儲和檢索時，每個存儲引擎都需要考慮不同的問題。
• 特殊功能：某些引擎支持特殊功能，例如全文搜索、參照完整性和處理空間數據的能力。
```

## 使用索引進行優化
• MySQL 使用索引（如果存在）來優化使用 WHERE 或 JOIN 子句的語句中的行查找。 索引： 
– 包含已排序的值 
– 減少磁盤 I/O 
– 執行它 強制唯一性約束
• 當您修改數據時，MySQL 會維護索引內容，這會對性能產生不利影響。
– 索引消耗額外的空間。
– 數據變化需要反映在索引中
```
MySQL 中的表可以增長得非常大； 但是，隨著表變大，對錶的查詢會變慢。 為了保持您的查詢性能良好，請在您的表上創建適當的索引。 創建表時，請考慮它是否應該有索引。 索引提供以下重要好處： 
• 索引包含已排序的值。 這允許 MySQL 更快地查找包含特定值的行。 連接的效果可能特別顯著，這可能需要檢查許多行組合。
• 索引會減少磁盤 I/O。 服務器使用索引直接訪問相關記錄，減少了需要讀取的記錄數。 此外，如果查詢僅顯示來自索引列的信息，MySQL 可能只能通過僅來自索引列的信息來處理它，MySQL 可能能夠通過僅讀取索引而不訪問數據行來處理它。
• 索引強制執行唯一性約束以確保不會出現重複值，並且可以將表中的每一行與其他每一行區分開來。
索引的缺點是有額外的開銷。 這種開銷會影響所有語句的性能，尤其是數據操作語言語句。
```

## 一般索引類型

MySQL 支持四種通用類型的索引： 
• 主鍵索引唯一標識每個表行。
– 主鍵不能包含空值，可以包含一列或多列。
– 一張表最多可以有一個主鍵。
• 唯一索引類似於主鍵索引，除了：
– 一個表可以有多個唯一索引 – 每個索引鍵中的每個字段都可以包含空值 – 每個非空鍵唯一標識每個表行 
• 非唯一索引是 任何鍵值都可以出現多次的索引。
• 外鍵索引引用另一個表的主鍵。
```
還有更多特殊類型的索引： 
• FULLTEXT 索引專為文本搜索而設計。
• SPATIAL 索引僅適用於具有空間數據類型的列索引僅適用於具有空間數據類型的列。
```

## 特殊索引類型
MySQL 還支持其他特殊類型的索引： 
• FULLTEXT 索引
– 允許全文搜索的列需要 
– 可用於 InnoDB 和 MyISAM 存儲引擎 – 數據更改時自動重建 
• SPATIAL 索引 
– 具有空間類型的索引列，例如 POINT 和 GEOMETRY 
– 僅適用於 InnoDB 和 MyISAM 表。 其他存儲引擎僅支持非空間索引。
```
全文搜索是一種基於關鍵字搜索信息的方式。 有關全文搜索的更多信息，請參閱標題為“使用字符串”的課程。 對於可使用全文搜索進行搜索的列，它必須是 CHAR、VARCHAR 或 TEXT 數據鍵入並在列上有一個 FULLTEXT 索引。
SPATIAL 索引提高了對具有空間數據類型的列的查找速度。  SPATIAL 索引僅適用於使用 InnoDB 或 MyISAM 存儲引擎的表。 其他支持空間類型的引擎僅支持使用 INDEX、UNIQUE 或 PRIMARY KEY 創建的非空間索引
```

## 創建索引
MySQL 允許您在數據庫生命週期的任何階段創建索引。
• 創建表時，將索引定義作為列定義的一部分包含在 CREATE TABLE 語句中。
• 使用 ALTER TABLE 或 CREATE INDEX 向現有表添加索引
```
要在創建表時為其定義索引，請將索引定義與列定義一起包含在 CREATE TABLE 語句中。 索引定義由適當的索引類型關鍵字或關鍵字組成，後跟要編制索引的列列表在括號內。
例子：
mysql> CREATE TABLE HeadOfState
-> (ID INT NOT NULL,
-> LastName CHAR(30) NOT NULL,
-> FirstName CHAR(30) NOT NULL,
-> CountryCode CHA > CountryCode CHAR(3) NOT NULL, NOT NULL,
-> Inauguration DATE NOT NULL,
-> INDEX (Inauguration)
-> );
注意：您可以使用關鍵字 KEY 而不是 INDEX
```

## 向新表添加索引
• 單列索引
```
mysql> CREATE TABLE HeadOfState (
-> ID INT NOT NULL,
-> LastName CHAR(30) NOT NULL,
-> FirstName CHAR(30) NOT NULL,
-> CountryCode CHAR(3) NOT NULL,
-> Inauguration DATE NOT NULL,
-> INDEX (Inauguration)
-> );
```
• 多列（複合）索引
```
mysql> CREATE TABLE HeadOfState ( -> ID INT NO U, T N LL, -> LastName CHAR(30) NOT NULL, -> FirstName CHAR(30) NOT NULL, -> CountryCode CHAR(3) NOT NULL, -> Inauguration DATE NOT NULL, -> INDEX (LastName, FirstName) -> );
```

要在創建表時為其定義索引，請將索引定義與列定義一起包含在 CREATE TABLE 語句中。 索引定義由適當的索引類型關鍵字或關鍵字組成，後跟要編制索引的列列表在括號內。
基於多列的索引稱為複合索引。 幻燈片中的第二個示例創建了一個複合索引，其中包括 HeadOfState 表的 LastName 和 FirstName 列。
注意：您可以使用關鍵字 KEY 而不是 INDEX。 這兩個關鍵字在 MySQL 中是同義詞。
13-18












