## 目標 
完成本課後，您應該能夠： 
• 描述可用於優化查詢的策略 • 描述查詢優化器的作用
• 使用 EXPLAIN 語句預測查詢性能 • 使用索引進行優化
• 描述 MySQL Enterprise Monitor 的作用 在查詢優化中

## 議程 
• 優化策略 
• MySQL 查詢優化器 
• 索引 
• 使用 EXPLAIN 語句進行查詢分析 • 重寫查詢 
• MySQL Enterprise Monitor

## 為什麼要優化？
優化涉及提高數據庫服務器和針對它運行的查詢的性能。
• 優化減少了查詢執行時間。
• 優化的查詢使使用服務器的每個人都受益。
– 查詢運行得越快，釋放表鎖的速度就越快，允許其他客戶端執行並減少查詢積壓的機會。
• 當服務器運行更流暢，以更少的工作處理更多的查詢時，它的整體性能會更好

## 優化策略
• 創建適當的索引。
• 重寫問題查詢。
• 使用EXPLAIN 語句調查優化機會。
• 考慮替代數據和應用程序設計。
• 考慮替代存儲引擎中可用的功能
```
索引 
減少表查找時間的最好方法是適當地索引你的表。 添加有效索引允許 MySQL 僅讀取表的相關部分，這樣會更快有效的索引允許 MySQL 只讀取表的相關部分，這比查詢和數據修改的全表掃描更快，磁盤密集度更低。
語句受益於在其 JOIN 或 WHERE 子句中使用索引列。
查詢重寫 
您編寫查詢的方式可能會阻止優化器使用索引，即使它可用。 重寫查詢可以讓優化器更有效地使用索引和處理查詢。
EXPLAIN 語句 
EXPLAIN 語句顯示優化器如何處理語句。 使用 EXPLAIN 深入了解如何提高查詢的性能。 例如，EXPLAIN 可以幫助確認您懷疑沒有正確使用索引。
數據和應用程序設計 
您有時可以通過使用不同的方法來提高查詢性能。 例如，您可以生成和維護匯總表，而不是從原始表數據中重複選擇。 表數據。
存儲引擎 
當您選擇具有最符合應用程序要求的屬性的存儲引擎時，查詢會更有效地運行
```

## SQL Parser 和 Query Optimizer 
服務器使用兩層處理模型執行語句，如下圖所示：
![[Pasted image 20211217135532.png]]
```
幻燈片中的圖表顯示了兩層： 
• 上層包括 SQL 解析器和優化器。
• 較低層包含一組存儲引擎，其中包括默認的 InnoDB下層包含一組存儲引擎，包括默認的 InnoDB。
無論使用什麼存儲引擎，大多數 SQL 語句的操作方式都相同：所有常用的 SQL 命令都獨立於存儲引擎。 服務器解析每個語句以查看它是哪種請求，然後使用其優化器來確定如何以最有效的方式執行該語句。  SQL 層不直接與語句命名的表交互。 優化器可能需要根據存儲引擎做出不同的選擇，但這都是通過每個存儲引擎支持的標準化接口 (API) 來處理的。
在大多數情況下，SQL 層不依賴於哪個存儲引擎管理任何給定的表。 這意味著客戶端通常不需要關心哪些引擎參與處理 SQL 語句，並且可以使用相同的 SQL 訪問和操作表，而不管管理它們的引擎。

SQL 語句的這種獨立於引擎的例外情況包括： • CREATE TABLE 有一個 ENGINE 選項，如果您不想使用默認的 InnoDB，您可以使用該選項指定在每個表的基礎上使用哪個存儲引擎。  ALTER TABLE 有一個 ENGINE 選項，使您能夠將表轉換為使用不同的存儲引擎。
• COMMIT 和 ROLLBACK 僅影響由事務存儲引擎（例如 InnoDB）管理的表。
以下屬性取決於存儲引擎： 
• 存儲介質：每個引擎都有自己的存儲表數據的方法。
• 事務能力：事務能力：某些存儲引擎支持事務處理某些存儲引擎支持事務處理以維護數據庫完整性。 請參閱標題為“交易”的課程。  
• 鎖定：每個存儲引擎負責限制多用戶環境中對資源的訪問。
• 備份和恢復：可用的備份技術因存儲引擎而異。
• 優化：在優化由該引擎管理的數據的存儲和檢索時，每個存儲引擎都需要考慮不同的問題。
• 特殊功能：某些引擎支持特殊功能，例如全文搜索、參照完整性和處理空間數據的能力。
```

## 使用索引進行優化
• MySQL 使用索引（如果存在）來優化使用 WHERE 或 JOIN 子句的語句中的行查找。 索引： 
– 包含已排序的值 
– 減少磁盤 I/O 
– 執行它 強制唯一性約束
• 當您修改數據時，MySQL 會維護索引內容，這會對性能產生不利影響。
– 索引消耗額外的空間。
– 數據變化需要反映在索引中
```
MySQL 中的表可以增長得非常大； 但是，隨著表變大，對錶的查詢會變慢。 為了保持您的查詢性能良好，請在您的表上創建適當的索引。 創建表時，請考慮它是否應該有索引。 索引提供以下重要好處： 
• 索引包含已排序的值。 這允許 MySQL 更快地查找包含特定值的行。 連接的效果可能特別顯著，這可能需要檢查許多行組合。
• 索引會減少磁盤 I/O。 服務器使用索引直接訪問相關記錄，減少了需要讀取的記錄數。 此外，如果查詢僅顯示來自索引列的信息，MySQL 可能只能通過僅來自索引列的信息來處理它，MySQL 可能能夠通過僅讀取索引而不訪問數據行來處理它。
• 索引強制執行唯一性約束以確保不會出現重複值，並且可以將表中的每一行與其他每一行區分開來。
索引的缺點是有額外的開銷。 這種開銷會影響所有語句的性能，尤其是數據操作語言語句。
```

## 一般索引類型

MySQL 支持四種通用類型的索引： 
• 主鍵索引唯一標識每個表行。
– 主鍵不能包含空值，可以包含一列或多列。
– 一張表最多可以有一個主鍵。
• 唯一索引類似於主鍵索引，除了：
– 一個表可以有多個唯一索引 – 每個索引鍵中的每個字段都可以包含空值 – 每個非空鍵唯一標識每個表行 
• 非唯一索引是 任何鍵值都可以出現多次的索引。
• 外鍵索引引用另一個表的主鍵。
```
還有更多特殊類型的索引： 
• FULLTEXT 索引專為文本搜索而設計。
• SPATIAL 索引僅適用於具有空間數據類型的列索引僅適用於具有空間數據類型的列。
```

## 特殊索引類型
MySQL 還支持其他特殊類型的索引： 
• FULLTEXT 索引
– 允許全文搜索的列需要 
– 可用於 InnoDB 和 MyISAM 存儲引擎 – 數據更改時自動重建 
• SPATIAL 索引 
– 具有空間類型的索引列，例如 POINT 和 GEOMETRY 
– 僅適用於 InnoDB 和 MyISAM 表。 其他存儲引擎僅支持非空間索引。
```
全文搜索是一種基於關鍵字搜索信息的方式。 有關全文搜索的更多信息，請參閱標題為“使用字符串”的課程。 對於可使用全文搜索進行搜索的列，它必須是 CHAR、VARCHAR 或 TEXT 數據鍵入並在列上有一個 FULLTEXT 索引。
SPATIAL 索引提高了對具有空間數據類型的列的查找速度。  SPATIAL 索引僅適用於使用 InnoDB 或 MyISAM 存儲引擎的表。 其他支持空間類型的引擎僅支持使用 INDEX、UNIQUE 或 PRIMARY KEY 創建的非空間索引
```

## 創建索引
MySQL 允許您在數據庫生命週期的任何階段創建索引。
• 創建表時，將索引定義作為列定義的一部分包含在 CREATE TABLE 語句中。
• 使用 ALTER TABLE 或 CREATE INDEX 向現有表添加索引
```
要在創建表時為其定義索引，請將索引定義與列定義一起包含在 CREATE TABLE 語句中。 索引定義由適當的索引類型關鍵字或關鍵字組成，後跟要編制索引的列列表在括號內。
例子：
mysql> CREATE TABLE HeadOfState
-> (ID INT NOT NULL,
-> LastName CHAR(30) NOT NULL,
-> FirstName CHAR(30) NOT NULL,
-> CountryCode CHA > CountryCode CHAR(3) NOT NULL, NOT NULL,
-> Inauguration DATE NOT NULL,
-> INDEX (Inauguration)
-> );
注意：您可以使用關鍵字 KEY 而不是 INDEX
```

## 向新表添加索引
• 單列索引
```
mysql> CREATE TABLE HeadOfState (
-> ID INT NOT NULL,
-> LastName CHAR(30) NOT NULL,
-> FirstName CHAR(30) NOT NULL,
-> CountryCode CHAR(3) NOT NULL,
-> Inauguration DATE NOT NULL,
-> INDEX (Inauguration)
-> );
```
• 多列（複合）索引
```
mysql> CREATE TABLE HeadOfState ( -> ID INT NO U, T N LL, -> LastName CHAR(30) NOT NULL, -> FirstName CHAR(30) NOT NULL, -> CountryCode CHAR(3) NOT NULL, -> Inauguration DATE NOT NULL, -> INDEX (LastName, FirstName) -> );
```
```
要在創建表時為其定義索引，請將索引定義與列定義一起包含在 CREATE TABLE 語句中。 索引定義由適當的索引類型關鍵字或關鍵字組成，後跟要編制索引的列列表在括號內。
基於多列的索引稱為複合索引。 幻燈片中的第二個示例創建了一個複合索引，其中包括 HeadOfState 表的 LastName 和 FirstName 列。
注意：您可以使用關鍵字 KEY 而不是 INDEX。 這兩個關鍵字在 MySQL 中是同義詞。
```

## 主鍵索引
PRIMARY KEY 是一種特殊類型的 UNIQUE 索引。 兩者的區別如下：
![[Pasted image 20211217210936.png]]
在 ID 列上創建 PRIMARY KEY 索引：
```
mysql> CREATE TABLE HeadOfState (
-> ID INT NOT NULL,
-> LastName CHAR(30) NOT NULL,
-> FirstName CHAR(30) NOT NULL,
-> CountryCode CHAR(3) NOT NULL,
-> Inauguration DATE NOT NULL,
-> PRIMARY KEY (ID) NOT NULL
-> );
```
```
PRIMARY KEY 是一種唯一值索引，但 UNIQUE 索引不一定是主鍵。
PRIMARY KEY 的內部名稱始終是 PRIMARY，並且只能有一個 
PRIMARY KEY 的內部名稱始終是 PRIMARY，並且每個表只能有一個主索引。 一個表可以支持多個 UNIQUE 索引。
如果您的索引必須包含唯一值並允許空值，請使用 UNIQUE 索引，而不是 PRIMARY KEY。 不允許空值的 UNIQUE 索引在功能上等同於 PRIMARY KEY。
要將列索引為 PRIMARY KEY，請使用關鍵字 PRIMARY KEY 而不是 UNIQUE 並聲明該列 NOT NULL 以禁止空值
```

## 命名索引
• 您可以通過在索引中的列列表之前指定索引名稱來顯式命名索引。 例如：
```
mysql> CREATE TABLE HeadOfState (
-> ID INT NOT NULL,
-> LastName CHAR(30) NOT NULL > LastName CHAR(30) NOT NULL,
-> FirstName CHAR(30) NOT NULL,
-> CountryCode CHAR(3) NOT NULL,
-> Inauguration DATE NOT NULL,
-> INDEX NameIndex (LastName, FirstName),
-> UNIQUE INDEX IDIndex (ID)
-> );
```
• 如果您沒有為索引提供名稱，MySQL 會根據索引中第一列的名稱分配名稱。
• 不能命名主鍵索引，因為它們都稱為 PRIMARY。

## 向現有表添加索引
使用 ALTER TABLE 或 CREATE INDEX 向現有表添加索引
• 更改表示例：
```
mysql> ALTER TABLE HeadOfState ADD PRIMARY KEY (ID);
mysql> ALTER TABLE HeadOfState ADD INDEX (LastName,FirstName);
```
– 這分別添加了一個主鍵和一個複合非唯一索引。
– 您可以選擇為索引提供名稱
• 創建索引示例
```
mysql> CREATE UNIQUE INDEX IDIndex ON HeadOfState (ID);
mysql> CREATE INDEX NameIndex ON HeadOfState (LastName,FirstName);
```
– 這將分別創建一個單列 UNIQUE 索引和一個多列非唯一索引。
– 您必須為索引提供一個名稱。
– 您不能使用 CREATE INDEX 添加 PRIMARY KEY。
```
您可以使用單個 ALTER TABLE 語句執行多項操作，例如同時向表添加多個索引。 這比單獨添加每個更有效。 您可以組合幻燈片示例中的兩個 ALTER TABLE 語句，版權所有 © 2017，Oracle 和/或其附屬公司。 版權所有。
如下：
mysql> ALTER TABLE HeadOfState ADD PRIMARY KEY (ID),
-> ADD INDEX (LastName,FirstName);
請注意，對於 CREATE INDEX，您必須為索引提供一個名稱。 使用 ALTER TABLE，如果您不提供索引名稱，MySQL 會自動創建一個索引名稱。
與 ALTER TABLE 不同，CREATE INDEX 語句為每個語句僅創建一個索引，並且只創建一個索引。 另外，只有ALTER TABLE ALTER TABLE 支持使用，支持使用PRIMARY KEY PRIMARY KEY。 由於這些原因，ALTER TABLE 更加靈活。
使用 ALTER TABLE 構建多個索引需要單次遍歷表數據，並且比多個 CREATE INDEX 語句更快。
```

## 使用索引前綴
為了節省空間並提高性能，當您的列數據在前 n 個字符內是唯一的時，僅索引列的前導部分。
• 您可以在CHAR、VARCHAR、BINARY、VARBINARY、BLOB 和TEXT 列上創建索引前綴。
• 必須始終為BLOB 和TEXT 列指定前綴長度。
```
對於 CHAR、VARCHAR、BINARY 和 VARBINARY 列，您可以通過指定可選的索引前綴長度來創建僅使用列值的前導部分的索引。 對於 BLOB 和 TEXT 列，必須指定前綴長度。 
CHAR、VARCHAR 和 TEXT 列的字符以及 BINARY、VARBINARY 和 BLOB 列的字節。
InnoDB 表的索引前綴最多為 767 字節，其他存儲引擎的索引前綴為 1000 字節。
如果列中的名稱通常在前 10 個字符中不同，則幻燈片中顯示的索引的性能類似於從整個名稱列創建的索引。 對索引使用部分列還減少了索引的大小，從而節省了大量磁盤空間並提高了 INSERT、UPDATE 和 DELETE 操作的性能。
索引值越短，處理越快。 因此，當列數據類型支持它時，請考慮索引部分列值而不是完整值。
```

## 索引沒有前綴的大列
• 考慮下表定義
```
mysql> CREATE TABLE t (
-> name CHAR(255),
-> INDEX (name)
-> );
```
如果將name列的255個字符全部索引，索引處理相對較慢：
– MySQL必須讀取更多信息。
– 更長的值需要更多的努力來比較。
– 索引緩存沒有那麼有效，因為它保存的鍵較少 索引緩存沒有那麼有效，因為它同時保存的鍵值較少。

## 帶前綴的索引
要為列指定前綴長度，請在索引定義中的列名後面加上括號中的數字。
• 下表定義與上一張幻燈片中的相同，不同之處在於索引中的鍵值僅使用列值的前 15 個字符：
``` 
mysql> CREATE TABLE t ( 
-> name CHAR(255), 
-> INDEX (name(15)) 
-> );  
```
• 這加速了查詢處理，但前提是中的值。  name 列在前 15 個字符內是唯一的。
```
您可以通過僅索引列值的前綴來克服上一張幻燈片中的問題。 例如，如果您希望所有 CHAR(255) 列值大部分時間在前 15 個字符內都是不同的，請索引每個值的前 15 個字符，而不是全部 255 人物
索引列前綴可加快查詢處理速度，但當前綴值與原始值具有大致相同的唯一性時效果最佳。 避免在索引中產生大量重複值的短前綴。 測試以找到提供良好唯一性的長索引值與比較速度更快但具有更多重複項的較短值之間的最佳平衡。
```

## 評估索引前綴
以下查詢給出了表中不同值和重複值的數量：
```
mysql> SELECT
-> COUNT(*) AS 'Total Rows',
-> COUNT(DISTINCT name) AS 'Distinct Values',
-> COUNT(*) - COUNT(DISTINCT name) AS 'Duplicate Values'
> FROM t;
```
以下查詢基於前綴值給出了類似的結果，使用 11 個字符作為示例前綴：
```
mysql> SELECT
-> COUNT(DISTINCT LEFT(name,11)) AS 'Distinct Prefix Values',
-> COUNT(*) - COUNT(DISTINCT LEFT(name,11))
-> AS 'Duplicate Prefix Values'
-> FROM t;
```
```
幻燈片中的第二個查詢演示了當您使用 11 個字符的前綴而不是完整值時，名稱列的“唯一性”如何變化。 使用不同的值運行查詢以確定可接受的前綴長度。
您可以組合幻燈片中的語句以生成單個結果，顯示所選前綴的性能：
SELECT
COUNT(*) AS 'Total Rows',
COUNT(DISTINCT name) AS 'Distinct Values',
COUNT(*) - COUNT(DISTINCT name) AS 'Duplicate Values‘
COUNT(DISTINCT LEFT(name,11)) AS 'Distinct Prefix Values',
COUNT(*) - COUNT(DISTINCT LEFT(name,11)) 
AS 'Duplicate Prefix Values'
FROM t;
```

## 最左邊的索引前綴
在具有復合（多列）索引的表中，MySQL 可以使用該索引最左邊的索引前綴。
• 複合索引最左邊的前綴由索引的一個或多個初始列組成。
• 索引條目首先根據最左邊的列進行排序和存儲，然後是第二列，依此類推在整個索引中。
• 最左邊的索引前綴可幫助您避免創建不必要的索引。
```
world 數據庫中的 CountryLanguage 表演示瞭如何應用最左邊的前綴。 該表在 CountryCode 和 Language 列上有一個由兩部分組成的主鍵：
```
![[Pasted image 20211217220058.png]]

## 最左邊的索引前綴：示例
world 數據庫中的 CountryLanguage 表：
mysql> SHOW INDEX FROM CountryLanguage\G
*************************** 1. row ***************************
Table: CountryLanguage
Non_unique: 0
Key_name: PRIMARY
Seq in index 1 Seq_in_index: 1
Column_name: CountryCode
Collation: A
Cardinality: NULL
...
Index_type: BTREE
Comment:
*************************** 2. row ***************************
Table: CountryLanguage
Non_unique: 0
Key_name: PRIMARY
Seq_in_index: 2
Column_name: Language
Collation: A
Cardinality: 984
...
Index_type: BTREE
Comment:
```
world 數據庫中的 CountryLanguage 表在 CountryCode 和 Language 列上有一個由兩部分組成的主鍵。 這些索引允許優化器根據給定的國家/地區名稱和語言快速查找記錄。 但是，MySQL 也可以使用僅給出國家/地區代碼時的索引。 假設您要確定法國使用哪些語言：
mysql> SELECT * FROM CountryLanguage WHERE CountryCode = 'FRA';
MySQL 確定 CountryCode 是主鍵最左邊的前綴，並將其用作單獨的索引。 所以不需要單獨在 CountryCode 列上定義第二個索引。
但是，如果您只想使用 CountryLanguage 表的 Language 列執行索引搜索，則必須創建單獨的索引，因為 Language 不是現有索引的最左側前綴
請注意，索引的最左前綴和列前綴上的索引是兩種不同的東西。
• 索引最左邊的前綴由多列索引中的前導列組成。
• 列前綴上的索引為列中值的前導字符編制索引。
```

## 刪除索引
要從表中刪除索引，請使用 ALTER TABLE 或 DROP INDEX
• 要使用 ALTER TABLE 刪除索引，請使用 DROP 子句並指定要刪除的索引（或 PRIMARY KEY）：
```
mysql> ALTER TABLE HeadOfState DROP PRIMARY KEY; 
mysql> ALTER TABLE HeadOfState DROP INDEX NameIndex;
```
• 要使用 DROP INDEX 刪除索引，請指明索引名稱和表名稱：
```
mysql> DROP INDEX NameIndex ON HeadOfState;
```
• 要使用 DROP INDEX 刪除主鍵，請使用索引名稱 PRIMARY，但要使用帶引號的標識符，因為 PRIMARY 是保留字：
```
mysql> DROP INDEX `PRIMARY` ON HeadOfState;
```
```
刪除索引與刪除數據庫或表不同。 刪除表是一種刪除數據的操作，除非從備份中恢復，否則無法撤消。 刪除索引時，不會刪除表數據，而只是刪除派生的結構從數據來看。 您可以在刪除索引後重新創建索引，只要構建索引的列沒有被刪除。
對於大表，刪除和重新創建索引可能是一項耗時的操作。
```

## 使用 EXPLAIN 分析查詢
使用 EXPLAIN 語句顯示有關查詢優化器如何處理 SELECT、DELETE、INSERT、REPLACE 或 UPDATE 操作的信息。 此信息在幾個方面很有用：
• EXPLAIN 可以提供標識需要的信息，可以提供標識需要添加索引的信息。
• 如果表已經有索引，您可以使用 EXPLAIN 來確定優化器是否正在使用它們。
• 如果索引存在但未被優化器使用，您不能嘗試以不同的方式編寫查詢。  EXPLAIN EXPLAIN 不能告訴您重寫的查詢是否更好地利用了可用索引。
```
使用 EXPLAIN 分析語句時，有助於很好地理解所涉及的表。 使用 DESCRIBE 和 SHOW CREATE TABLE 獲取有關表列的信息，使用 SHOW INDEX 獲取有關其索引的信息。
有關所有 EXPLAIN 輸出列的完整說明，請參閱 http://dev.mysql.com/doc/mysql/en/explain-output.html。
```

## 解釋的工作原理
要使用 EXPLAIN，請像往常一樣編寫 SELECT、DELETE、INSERT、REPLACE 或 UPDATE 語句，但將關鍵字 EXPLAIN 放在它前面。 例如，要檢查針對 sakila 數據庫的租用表的兩個等效查詢的執行計劃：
```
EXPLAIN SELECT * FROM rental WHERE 
YEAR(rental_date) >= 2006\G
EXPLAIN SELECT * FROM rental WHERE 
rental_date >= '2006-01-01'\G
```
使用 EXPLAIN 來驗證 MySQL 是否使用索引來處理操作。  EXPLAIN 從優化器中檢索有關它將如何執行語句的信息。

## EXPLAIN 輸出：示例 1
在以下示例中，優化器沒有可用的鍵，因此必須執行全表掃描（類型：ALL）以讀取租用表中的所有 16,318 行：
```
mysql> EXPLAIN SELECT * FROM rental WHERE 
-> YEAR(rental_date) >= 2006\G
********************** 1. row **********************
id: 1
select_type: SIMPLE
table: rental
type: ALL
possible_keys: NULL
key: NULL
key_len: NULL
ref: NULL
rows: 16318
Extra: Using where
```

## EXPLAIN 輸出：示例 2
在以下示例中，優化器可以使用rental_date 索引執行範圍掃描，從而大大減少它必須從租賃表中讀取的行數：
```
mysql> EXPLAIN SELECT * FROM rental WHERE 
-> rent l d t '2006 tal_date >= '2006-01-01'\G
********************** 1. row **********************
id: 1
select_type: SIMPLE
table: rental
type: range
possible_keys: rental_date
key: rental date key: rental_date
key_len: 8
ref: NULL
rows: 181
Extra: Using where
```

## 解釋輸出列
• 要有效地使用 EXPLAIN，您必須知道每行輸出中的列的含義。 輸出取決於查詢中可解釋語句的數量以及涉及的表的數量。
• EXPLAIN 語句為每個語句生成一行輸出，為查詢中的每個表查找或掃描生成一行輸出，以及派生表和具體化子查詢的行。
• 《MySQL 參考手冊》中提供了 EXPLAIN 列、它們可能的值和含義的完整列表。
```
以下列表描述了使用 EXPLAIN 時輸出行中顯示的列： • id 表示輸出行在分析語句中引用的 SELECT。
• 選擇類型對輸出行引用的 SELECT 進行分類select_type 對輸出行引用的 SELECT 進行分類。 此列可以具有以下列表中顯示的任何值。 單詞 DEPENDENT 表示子查詢與外部查詢相關。
- SIMPLE：簡單的 SELECT 語句（無子查詢或聯合） 
- PRIMARY：外部 SELECT 
- UNION：聯合中的第二個或更高版本的 SELECT 
- DEPENDENT UNION DEPENDENT UNION：第二個或更高版本 依賴於 in 的聯合中的第二個或更高版本 SELECT 依賴於外部查詢的聯合 
- UNION RESULT：聯合的結果 
- SUBQUERY：子查詢中的第一個 SELECT 
- DEPENDENT SUBQUERY：依賴於外部查詢的子查詢中的第一個 SELECT 
- DERIVED：子查詢中的子查詢 FROM 子句 - MATERIALIZED：物化子查詢
- UNCACHEABLE SUBQUERY：無法緩存結果並且必須為外部查詢的每一行重新評估的子查詢
- UNCACHEABLE UNION：UNION 中屬於不可緩存子q y的第二個或以後的選擇
• table 是應用該行中的信息的表的名稱。 行的順序表示 MySQL 讀取表以處理查詢的順序。 這不一定是您在 FROM 子句中命名它們的順序，因為優化器會嘗試確定哪種順序會導致最有效的處理。 連續 EXPLAIN 語句顯示的表順序可以隨著索引的添加而改變。
• type 表示連接類型 該值是衡量 MySQL 掃描表示連接類型的效率的指標。 該值用於衡量 MySQL 掃描表的效率。
• type 表示連接類型 該值是衡量 MySQL 掃描表示連接類型的效率的指標。 該值用於衡量 MySQL 掃描表的效率。
• key 表示優化器關於在可能的 ke _ ys y qy 中列出的候選索引中的哪個候選索引產生最有效的查詢執行的決定。 如果鍵值為NULL，則表示沒有索引是最佳的。 這可能是因為沒有候選者或者因為優化器認為掃描表行與使用任何可能的索引一樣快； 例如，如果表很小，或者因為索引會產生表中行的百分比太高而比表掃描更有效。
• key_len 指示使用了多少字節的索引行。 根據該值，您可以推導出索引中使用了多少列。 例如，如果您有一個由三個 INT 列組成的索引，每個索引行包含三個 4 列，則每個索引行包含三個 4 字節值如果字節值。 如果 key_len 為 12，則您知道優化器在處理查詢時使用索引的所有三列。 如果 key_len 是 4 或 8，它只使用前一或前兩列。
也就是說，它使用索引最左邊的前綴。
在評估 key_len 值時考慮任何列索引前綴。 例如，如果您在兩個 CHAR(8) 列上有一個複合索引，該索引僅索引每列的前 4 個字節，則 key_len 值為 8 意味著優化器使用索引的兩列，而不僅僅是第一列 索引，而不僅僅是第一列
• ref 包含NULL、const 或早期表中的完全限定列，指示優化器使用哪個或哪些索引列從當前表中選擇行。  const 表示將索引中的鍵值與常量表達式進行比較，例如 Code='FRA'。  NULL 表示優化器既不使用常量也不使用其他列，表示通過表達式或值範圍進行選擇。 它還可能表示該列不包含常量表達式指定的值。 如果 NULL 和 const 都不顯示，EXPLAIN 顯示一個 table_name.column_name 組合，表明優化器正在從 table_name 返回的行中查看 column_name 以識別當前表的行
• rows 是優化器對它需要檢查的表中的行數的估計。
該值是一個近似值，因為通常情況下，如果不實際執行查詢，MySQL 無法知道確切的行數。 對於多表查詢，行值的乘積是需要讀取的行組合總數的估計值。 該產品為您提供了查詢性能的粗略衡量標準。 值越小越好。• 過濾表示按表條件過濾的表行的估計百分比。
• Extra 提供有關連接的其他信息。 下面的幻燈片討論了這些信息。
有關 EXPLAIN 的完整說明，請參閱 M SQL R f MySQL 參考手冊：http://dev.mysql.com/doc/mysql/en/explain-output.html
```
## EXPLAIN 連接分析
使用 EXPLAIN 輸出中的類型列進行連接分析。 例如，以下查詢的類型值為 const，因為 MySQL 服務器必須只讀取一行，由於主鍵
```
mysql> EXPLAIN SELECT * FROM Country WHERE Code = 'FRA'\G
******************** 1. row ********************
id: 1
select_type: SIMPLE
table: Country
type: const
possible keys: PRIMARY possible_keys: PRIMARY
key: PRIMARY
key_len: 3
ref: const
rows: 1
Extra:
```
```
在優化數據庫應用程序時，聯接需要仔細考慮。 如果您從具有 1,000 行的表中進行選擇，最壞的情況是服務器必須掃描所有 1,000 行。 但是，如果您在兩個表之間執行連接，每個表有 1,000 行，最壞的情況是，服務器需要檢查每一種可能的行組合，即一百萬種組合。 EXPLAIN 可幫助您確定服務器為處理此類查詢必須執行的工作，從而幫助您優化查詢。如果通過分析連接的 EXPLAIN 語句的輸出，您認為首先讀取左表可以獲得更高的效率，那麼請考慮使用 STRAIGHT JOIN。 STRAIGHT JOIN 在連接優化器以錯誤順序列出表的極少數情況下很有用。有關以錯誤順序排列的表的更多信息。 有關 STRAIGHT JOIN STRAIGHT JOIN 的更多信息，請參閱 MySQL 參考手冊，網址為：http://dev.mysql.com/doc/mysql/en/join.html。
```

## 解釋類型
下面的列表顯示了 type 的可能值，從最好到最差： • system：表只有一行。
• const：該表只有一個匹配行。
• eq_ref：對於EXPLAIN 列出的表中的每個行組合，該表只有一行。
• ref：該表包含多個匹配行，用於查詢中來自其他表的行的組合。
```
MySQL 以不同程度的效率執行連接。 類型值通過指示從每個表中選擇行的基礎來提供此效率的度量。
以下列表顯示了從最佳類型到最差類型的可能值：
• 系統：表只有一行。
• const：該表只有一個匹配行。 此類型值與 system 類似，不同之處在於該表可以具有其他不匹配的行。 在上一張幻燈片的示例中，EXPLAIN 顯示類型“const”。 如果表僅包含“France”行，則類型值將是 system 而不是 const。
• eq_ref：對於EXPLAIN EXPLAIN 列出的表li t d b 中的每個行組合，該表恰好有一行。  Thi i f j i h M SQL i k t 這對於 MySQL 使用主鍵來標識表行的連接很常見。
• ref：該表包含多個匹配行，用於查詢中來自其他表的行的組合。 這與 eq_ref 類似，但在使用非唯一索引來標識表行或僅使用索引的最左側前綴時可能會發生。 例如，CountryLanguage 表在 CountryCode 和 Language 列上有一個主鍵。 如果您只使用 CountryCode 值進行搜索，MySQL 可以使用該列作為最左邊的前綴，但如果在那裡使用多種語言，一個國家可能會有幾行
```

## 解釋類型
• ref_or_null：作為 ref，也包含 NULL 的行
• fulltext：MySQL 使用的 FULLTEXT 索引
• index_merge：MySQL 使用的索引合併算法 
• unique_subquery：作為 ref，但用於從主鍵列中選擇的 IN 子查詢 單桌。
• index_subquery：作為unique_subquery，但用於從單個表的索引列中選擇的IN 子查詢
• range：選擇落入給定索引值範圍內的gg 行
• index：完全掃描索引而不是數據行 
• ALL： 全表掃描所有數據行
```
• ref_or_null：與ref 類似，但MySQL 也會查找包含NULL 的行。
• fulltext：MySQL 使用 FULLTEXT 索引。
• 索引合併：MySQL 使用索引合併算法index_merge：MySQL 使用索引合併算法。
• unique_subquery：類似於ref，但用於從單個表的主鍵列中進行選擇的IN 子查詢。
• index_subquery：類似於unique_subquery，但用於從單個表的索引列中進行選擇的IN 子查詢。
• 範圍：優化器使用索引來選擇落在給定索引值範圍內的行。 這對於 id < 10 等不平等的 puality 比較很常見。
• 索引：MySQL 執行完整掃描，但它掃描索引而不是數據行。
索引行通常比數據行短，因此與掃描整個表相比，掃描索引更快並且使用更少的資源。
• ALL：所有數據行的全表掃描。 通常，這表示沒有進行優化並且代表最壞的情況。 當後面在 EXPLAIN 輸出中列出的表的聯接類型為 ALL 時，它表示對從聯接中較早處理的表中選擇的行的每個組合進行表掃描。
```

## 額外列：有效查詢的標誌
Extra 列提供有關如何處理表的附加信息。 一些值表明該語句是有效的： 
• 使用索引：MySQL 通過從索引中讀取值來優化查詢，而不必從索引中讀取相應的數據，而不必讀取相應的數據行。
• Where used：MySQL 使用 WHERE 子句來標識滿足查詢的行。
• Distinct：MySQL 從前面 EXPLAIN 輸出中列出的表中的行的每個組合組合中讀取一行。
• 不存在：MySQL 通過使用 LEFT JOIN 優化查詢以排除行

## 額外列：低效查詢的跡象
相比之下，一些 Extra 值表示查詢效率不高： 
• Using filesort：滿足查詢的行必須排序，這增加了額外的處理步驟。
• 使用臨時：必須創建一個臨時表來處理查詢。
• 對每條記錄進行範圍檢查：MySQL 無法預先確定要使用表中的哪個索引。 對於從先前表中選擇的每個行組合，它會檢查表中的索引以查看哪一個是最好的。
使用文件排序和使用臨時是性能不佳的最強指標
```
如果優化器在內存中執行操作，則該操作比優化器必須使用硬盤更快。 使用文件排序和使用臨時可能表示性能不佳，因為它們意味著優化器需要使用排序操作或臨時表，分別。 如果它們需要的緩衝區空間超過可用空間，這兩種方法都可能導致文件 I/O。
如果排序緩衝區大小足以容納排序操作，則可以在內存中執行，無需任何文件 I/O。 您可以增加排序緩衝區大小來增加優化器選擇使用硬盤的閾值，但這並不總是一個好的解決方案，因為每個連接都會分配排序緩衝區大小中的全部字節數，即使它僅使用 即使它只使用了那個數量的一小部分。
為每個排序分配大的全局排序緩衝區大小會減慢服務器的操作，因此您必須首先確定是否可以優化問題語句，然後才考慮增加排序緩衝區大小。 排序緩衝區大小可以作為全局變量或會話變量增加，因此您可以考慮增加它以提高單個操作的性能。
```
## 以 JavaScript 對象表示法 (JSON) 格式的 EXPLAIN 輸出
• EXPLAIN FORMAT=JSON 以 JSON 格式顯示信息：
```
mysql> EXPLAIN FORMAT=JSON SELECT * FROM Country WHERE Code = 'FRA'\G
*********************** 1. row ***************************
EXPLAIN: { EXPLAIN: {
"query_block": {
"select_id": 1,
"cost_info": {
"query_cost": "1.00"
},
"table": {
"table_name": "Country",
"access_type": "const",
"possible_keys": [
"PRIMARY"
], ...
```
```
注意：本課程在題為“NoSQL”的課程中更詳細地討論了 JSON。
```

## 總結 
在本課中，您應該已經學會瞭如何： 
• 描述查詢優化器的作用 
• 描述可用於優化查詢的策略 
• 使用 EXPLAIN 語句預測查詢性能 
• 使用索引進行優化 
• 描述 MySQL Enterprise Monitor 的作用 在查詢優化中








