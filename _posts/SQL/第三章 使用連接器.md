## 完成本課程後，您應該能夠：
## 目標完成本課程後，您應該能夠：
完成本課程後，您應該能夠：
• 列出使用準備好的語句的原因及其限制
• 描述 SQL 注入以及準備好的語句如何幫助保護它
• 使用 mysql 命令行客戶端準備、執行和取消分配準備好的語句
• 在帶有連接器的代碼中使用準備好的語句

## 議程
• 使用準備好的語句的原因
• 用戶定義的變量
• 準備、執行和釋放準備好的語句
• 將準備好的語句與連接器一起使用

## 為什麼要使用準備好的語句？
• 提高查詢性能。 您準備一個語句並執行多次，每次使用不同的數據值。
– 服務器僅解析語句一次，當它準備語句時，為該語句創建新協議，為該語句創建新協議。
– 服務器僅解析語句一次，當它準備語句時，為該語句創建新協議，為該語句創建新協議。
— 減少服務器 CPU 開銷 
— 與單獨發送每個語句相比，減少了服務器和客戶端之間的網絡流量
• 為確保數據類型在 SQL 語句中正確引用
• 避免 SQL 注入通常，您使用連接器從程序代碼準備和執行語句。
但是，為了幫助測試和調試，您可以從 mysql 命令行客戶端中定義和執行準備好的語句。
當服務器準備一條語句時，它會為該語句創建一個協議。 通常，客戶端將 SQL 語句與值一起傳遞，這些值由服務器從原始文本字符串中解析出來。 預準備語句的協議將值與語句的其餘部分分開，並提供一種二進制機制來傳輸值。 這比在字符串之間進行轉換更有效。
準備好的語句還有助於防止一種稱為 SQL 注入的攻擊形式。 惡意的 SQL 惡意用戶可以將 SQL 命令插入到需要值的應用程序中。 準備好的語句將 SQL 命令與值分開，並防止將值解釋為 SQL 語句。
```
通常，您使用連接器從程序代碼準備和執行語句。
但是，為了幫助測試和調試，您可以從 mysql 命令行客戶端中定義和執行準備好的語句。
當服務器準備一條語句時，它會為該語句創建一個協議。 通常，客戶端將 SQL 語句與值一起傳遞，這些值由服務器從原始文本字符串中解析出來。 預準備語句的協議將值與語句的其餘部分分開，並提供一種二進制機制來傳輸值。 這比在字符串之間進行轉換更有效。
準備好的語句還有助於防止一種稱為 SQL 注入的攻擊形式。 惡意的 SQL 惡意用戶可以將 SQL 命令插入到需要值的應用程序中。 準備好的語句將 SQL 命令與值分開，並防止將值解釋為 SQL 語句。
```

## 準備報表的局限性
• 不能嵌套準備好的語句。
– 您要準備的語句不能包含 PREPARE、EXECUTE 或 DEALLOCATE PREPARE。
• 只能準備單個語句，不能準備多語句。
– 多語句由單個字符串中的多個語句組成，由終止符分隔。
• 您不能準備某些類型的報表。 例如： – LOCK TABLES/UNLOCK TABLES, LOAD DATA/LOAD TABLE, ALTER VIEW
– 診斷語句（診斷語句（SHOW ERRORS/SHOW WARNINGS SHOW ERRORS/SHOW WARNINGS）
• 不能準備包含動態游標聲明的語句。
– 這是因為 MySQL 在創建游標時會檢查游標語法/語句

```
MySQL 不允許您準備每種類型的 SQL 語句。 允許的語句列表類似於存儲例程中允許的語句。
MySQL 5.7.2及更高版本，不能按照SQL標準的要求準備診斷語句。 診斷語句包括：
• SHOW ERRORS/WARNINGS 
• SIGNAL/RESIGNAL 
• GET DIAGNOSTICS 
• 任何引用warning_count 或error_count 系統變量的語句
注意 
• 有關準備好的語句中允許的 SQL 語句的完整列表，請參閱：https://dev.mysql.com/doc/mysql/en/sql-syntax-prepared-statements.html。
• 本課程涵蓋題為“存儲例程”的課程中的存儲例程。
```

## SQL注入
SQL 注入是一種技術，惡意用戶可以通過基於表單的輸入將 SQL 命令注入到 Web 應用程序中。
示例： 
• 服務器代碼：
```
parse_str($_SERVER['QUERY_STRING']);
$sql = "SELECT * FROM Users WHERE UserId = " + $UserId;
$rs = $mysqli->query(sql);

```
• 表格輸入：
![[Pasted image 20211217092550.png]]
• 結果 SQL：
```
SELECT * FROM Users WHERE UserId = 11000 OR 1=1;
SELECT * FROM Users WHERE UserId = 22; DROP TABLE tb11;
```
```
幻燈片中的示例顯示了當 SQL 不使用參數化查詢（如預準備語句啟用的查詢）時，惡意用戶如何將可能有害的 SQL 代碼注入到基於 Web 的表單中。
在此 Web 應用程序中，用戶在 HTML 表單中的用戶 ID 文本框中輸入一個值。 瀏覽器將表單提交給服務器。  Web 應用程序檢索輸入的值，將其存儲在名為 txtUserID 的變量中，將其附加到包含 SQL 語句的字符串，然後執行查詢。
示例 1：用戶在用戶 ID 文本框中輸入 11000 OR 1=1。 當這個文本被附加到 SQL 語句中時，因為 1=1 總是為真，MySQL 服務器返回所有記錄。如果記錄是一個真正的安全風險。 如果用戶表包含密碼數據表包含密碼數據，則這是一個真正的安全風險。
例2：用戶輸入22； 刪除表 tbl1; 添加分號允許將兩條 SQL 語句作為批處理執行，其中第二條會刪除 tbl1 表並可能導致災難性的數據丟失。
準備好的語句有助於防止 SQL 注入，因為要插入 SQL 查詢的值會獨立於查詢本身發送到 MySQL 服務器。 這意味著這些值總是被解釋為數據而不是 SQL 代碼值總是被解釋為數據而不是 SQL 代碼。
```
## 用戶定義的變量
您可以將值存儲在用戶定義的變量（也稱為用戶變量）中，然後從其他語句（包括準備好的語句）中引用它。 用戶定義的變量：
• 看起來像：@var_name
• 通過使用 SET  語句分配一個值：
```
SET @var_name = expr [, @var_name = expr] ...
```
– 該值必須是整數、實數、字符串或空類型。
– 如果該值來自結果集，則 SET 語句將該值視為字符串。
• 屬於創建它們的連接。 其他連接無法訪問它們。
– 當客戶端斷開連接時，服務器會釋放連接期間創建的所有變量。
```
用戶變量具有與表名和列名相同的命名條件。 變量名由當前字符集中的字母數字字符以及字符“.”、“_”和“$”組成。 要在變量名稱中使用其他字符，請包括整個名稱作為 版權所有 © 2017，Oracle 和/或其附屬公司。 版權所有。
引號內的字符串或標識符。 例如，@'my-var'、@"my-var" 或 @`my-var`。
對於 SET，使用 = 或 := 作為賦值運算符。 將值（文字或表達式）分配給變量時，該值的數據類型必須是整數、實數、字符串或 NULL。
但是，如果變量的值來自結果集，則 SET 語句將該值視為字符串。
如果將字符串分配給用戶變量，則該變量使用與字符串相同的字符集和排序規則。 用戶變量的可強制性是隱含的。  （Coercibility 定義在單個表達式中的值之間的排序規則衝突的情況下轉換哪個值的排序規則。）當您插入或更新具有與表中定義的排序規則不同的排序規則的字符串時，這與表列值的工作方式相同
```

## 準備聲明
• 使用 PREPARE 準備語句
```
PREPARE statement_name FROM preparable_statement
```
– statement_name 是一個標識符，因此您可以稍後參考該語句。 它不區分大小寫。
– preparable 語句 preparable_statement 要么是字符串文字，要么用戶要么是字符串文字，要么是包含 SQL 語句文本的用戶變量。
- 使用 ？ 字符作為參數標記，指示執行語句時數據值將在哪裡綁定到語句。
— 僅使用參數標記來表示數據值，而不是 SQL 關鍵字、表或列名稱等。
— 不要將參數標記括在引號中，即使您需要一個字符串值
• 準備好的語句僅存在於創建它的會話範圍內。
```
您可以準備完整的陳述或不完整的陳述。 完整語句包含執行語句所需的所有 SQL 代碼和值。 不完整的語句包含在準備時未知的數據值的佔位符。 
佔位符由問號“?”字符表示。 執行語句時，必須提供特定的數據值，語句中的每個參數一個。 服務器用您提供的數據值替換標記以完成語句。 每次執行語句時都可以使用不同的值。
如果您嘗試準備一個與已經存在的語句同名的語句，MySQL 會在準備新語句之前釋放當前語句。 如果由於任何原因無法準備新語句，MySQL 引發錯誤並且由於任何原因沒有重新準備，MySQL 會引發錯誤並且不會重新創建先前的 create 先前語句。
準備好的語句只存在於創建它的會話中，並且不可用於其他客戶端連接。 如果會話因任何原因結束，其準備好的語句將自動解除分配。 這可能會在存儲例程的上下文中導致不需要的副作用。
注意：本課程在“存儲例程”課程中介紹了在存儲例程中使用準備好的語句。
```

## 執行準備好的語句
服務器準備好語句後，您就可以執行它了。
• 如果語句包含任何問號“？” 參數標記，您必須提供一個用戶變量，該變量包含每個標記的兼容數據類型的值。
• 要執行準備好的語句，請發出EXECUTE...USING 語句。 例如
```
SET @var1 = 'USA';
EXECUTE my_prepared_stmt USING @var1;
SET @var2 = 'GBR';
EXECUTE my prepared stmt USING @var2;
```
• 如果語句不包含參數標記，則省略 USING 子句。
```
USING 子句必須命名與語句中的參數標記一樣多的值，並且值的替換順序與它們列出的順序相同。
如果在準備好的語句中引用一個尚未設置的值，則其值為 NULL
```

## 釋放準備好的語句
準備好的語句佔用內存空間。 要釋放該空間，您必須釋放準備好的語句。
• 當您執行以下操作時，服務器會自動取消分配準備好的語句： 
– 重新定義另一個同名的準備好的語句 – 關閉與服務器的連接 
• 您可以使用 DEALLOCATE PREPARE 顯式取消分配準備好的語句：
```
mysql> DEALLOCATE PREPARE my_prepared_stmt;
Q O 0 ff d (# ## )
```
準備好的語句示例：SQL

## 準備好的語句示例：SQL
mysql> PREPARE my_stmt FROM
-> 'SELECT COUNT(*) FROM CountryLanguage
-> WHERE CountryCode= ?';
Query OK, 0 rows affected (#.## sec)
Statement prepared
mysql> SET @code 'ESP'; SET @code = 'ESP';
mysql> EXECUTE my_stmt USING @code;
Query OK, 0 rows affected (#.## sec)
+----------+
| COUNT(*) |
+----------+
|4                 
+----------+
1 row in set (#.## sec)
mysql> DEALLOCATE PREPARE my_stmt;
Query OK, 0 rows affected (#.## sec)
```
幻燈片中的示例準備了一個語句，該語句確定給定國家/地區使用的語言數量，執行它（使用用戶變量），然後釋放它。 您可以多次執行準備好的語句，為每個 @code 指定一個新值
以下示例演示了使用多�