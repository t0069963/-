# 事務的 ACID 屬性
事務系統符合 ACID，其中“ACID”代表：
• 原子性：所有語句成功執行或作為一個單元被取消。 交易是“全有或全無”。
• 組成：一個事務將數據庫從一種一致的數據狀態更改為另一種。
• 隔離：一個事務不影響另一個。 每個事務都會鎖定其各個步驟的結果，直到整個事務結束。
• 持久：成功結束的事務所做的所有更改都正確記錄在數據庫中。 更改不會丟失。
```
事務處理不僅為數據庫操作的結果提供了更強的保證，而且還需要更多的 CPU 週期、內存和磁盤空間開銷。 某些應用程序比其他應用程序更需要事務提供的保證 
應用程序。
例如，金融操作通常需要交易，數據完整性的保證超過額外開銷的成本。 如果服務器主機崩潰，將網頁訪問記錄到數據庫表的應用程序可能可以容忍一些記錄的丟失。
```

## 事務控制語句
使用以下語句顯式控制事務：
• 開始交易（或開始）：開始一個新的交易
• COMMIT：提交當前事務，使其更改永久化
• ROLLBACK：回滾當前事務，取消其更改
• SET AUTOCOMMIT：禁用或啟用當前連接的默認自動提交模式
```
InnoDB 是 MySQL 中的默認存儲引擎。  InnoDB 和 ndb（用於 MySQL 集群）是唯一支持事務的存儲引擎。 本課中的信息不適用於使用不同存儲引擎的表。
```
## 自動提交模式
自動提交模式決定了新事務的啟動方式和時間
• 啟用（默認）： 
– 單個 SQL 語句隱式啟動一個新事務。
– 對錶的所有更改都會立即生效。
– 您可以使用 START TRANSACTION 語句執行多語句事務，該語句會暫時禁用自動提交，直到您執行 COMMIT 或 ROLLBACK。
• 禁用： – T tilti l t t t t b d f lt 默認情況下，事務跨越多個語句。
– 您必須明確 COMMIT 事務以保持其效果或 ROLLBACK 取消它。
```
啟用自動提交 
啟用自動提交將每個語句包裝在它自己的事務中。 啟用自動提交後，每條語句都作為一個事務執行。 如果語句成功執行，語句作為事務執行。 如果語句成功執行，則存在隱式 COMMIT 並永久保存更改。 如果語句失敗，事務將自動回滾，並撤消任何部分完成的更改。
啟用自動提交模式後，您可以使用 START TRANSACTION 語句顯式啟動事務。 這會暫時禁用自動提交，以便事務可以跨越多個語句，而不會自動提交每個語句。 當您執行 COMMIT 或 ROLLBACK 時，自動提交再次啟用
禁用自動提交 
禁用自動提交時，您必須分別使用 COMMIT 和 ROLLBACK 語句顯式提交或回滾事務。 事務終止後，MySQL 隱式啟動一個新事務。
如果在事務中執行的語句失敗，則由該語句引起的任何更改都將撤消，但整個事務不會終止。 事務保持打開狀態，o 可以將事務作為漏洞提交或回滾
```
## 控制自動提交模式
服務器變量 autocommit 指定是否啟用自動提交模式。
• 默認情況下，為新會話啟用自動提交。
• 在當前會話中禁用自動提交：
```
mysql> SET autocommit = OFF;
```
• 在選項文件中全局禁用自動提交：
```
[mysqld] 
autocommit=0
```
• 使用 mysqld 啟動選項全局禁用自動提交：
```
# mysqld --autocommit=0
```
```
默認情況下，啟用自動提交。 要執行跨多個語句的事務，請通過發出 SET 語句禁用自動提交。 或者，您可以更改服務器配置以通過在公司中設置 autocommit=0 選項來全局禁用自動提交。 版權所有。
選項文件，或通過在命令行中使用啟動選項。
```
## 導致隱式提交的語句
• COMMIT 語句將當前事務對數據庫的影響顯式持久化
• 許多語句隱式提交事務，包括： – 事務控制語句，例如 START TRANSACTION 和 SET a tocommit ON SET autocommit = ON；  
– 數據定義語言語句 (DDL)，例如 ALTER、CREATE、DROP 和 TRUNCATE TABLE。
– 數據訪問和用戶管理語句，例如 GRANT、REVOKE、SET PASSWORD – 鎖定語句，例如 Locking 語句，例如 LOCK TABLES LOCK TABLES
• 導致隱式 COMMIT 的語句無法回滾
```
一些語句隱式地提交（從而終止）當前事務。 這些語句的行為就像您在執行實際語句之前立即執行 COMMIT 一樣。 此外，這些聲明本身是非交易性的，這意味著如果它們成功，您將無法回滾它們
```

## 對交易報表進行編碼的一般方法
• 所有MySQL API 都支持事務。
– 許多 API 提供用於處理事務的抽象接口。
— 您可以通過啟用然後檢查通用查詢日誌來查看生成的 SQL 語句。
– 與其他人一起，您必須自己構建事務性 SQL 語句
• 在執行交易的代碼中：
– 使用您的編程語言處理異常的能力（如果存在）
— 執行塊中的事務語句。
— 如果塊中的語句失敗，則引發異常並回滾。
– 將確定是否需要回滾所需的測試量保持在最低限度。
```
檢查事務中每條語句的成功或失敗會導致性能不佳和代碼難以閱讀。 相反，在塊中執行您的 SQL 語句。 如果您選擇的編程語言支持異常處理，則在關鍵時引發異常塊中的語句失敗並在異常處理程序中回滾。
注意：您還必須檢查回滾本身是否引發異常並妥善處理； 否則，您的整個程序可能會崩潰。
```

## 在 PHP/PDO 中編寫事務性語句
```
01 try
02 {
03 $dbh->beginTransaction ();
04 $dbh->exec ("UPDATE Country SET GNP = (GNP * 1.1) WHERE Name = 
'Armenia'");
05 $dbh->exec ("UPDATE Country SET GNP = (GNP * 1.1) WHERE Name = 
'Bermuda Bermuda ); '"
06 $dbh->commit ();
07 }
08 catch (Exception $e)
09 {
10 print ("Transaction failed, rolling back. Error was:\n");
11 print ($e->getMessage () . "\n");
12 try
13 {
14 $dbh->rollback ();
15 }
16 catch (Exception $er) {
17 print ("Unable to roll back. Error was:\n");
18 print ($er->getMessage () . "\n");
19 }
20 }
```
```
在幻燈片的示例中： • 在第 3 行，程序調用 beginTransaction() 方法來啟動事務。
• 執行從第 1 行開始的初始 try 塊中的語句 如果它們是 版權所有 © 2017，Oracle 和/或其附屬公司。 版權所有。
執行從第 1 行開始的初始 try 塊中的語句。 如果它們成功，它們將通過第 6 行中的 commit() 方法持久化到數據庫中。
• 如果第一個 try 塊中的任一 UPDATE 語句失敗，程序將引發異常，該異常在第 8 行中被捕獲。
• 程序顯示一條消息並嘗試使用第 14 行中的 rollback() 方法進行回滾。
• 回滾本身在 try 塊中執行，因此如果失敗， p 會引發異常並在第 16 行捕獲。
```

## 在 Connector/J 中編寫交易語句
```
01 try {
02 conn.setAutoCommit (false);
03 Statement s = conn.createStatement ();
04 s.executeUpdate ("UPDATE Country SET GNP = (GNP * 1.1) WHERE Name 
= 'Armenia'");
05 s.executeUpdate ("UPDATE Country SET GNP = (GNP * 1.1) WHERE Name
= 'Bermuda'");
06 s.close ();
07 conn.commit ();
08 conn.setAutoCommit (true);
09 }
10 catch (SQLException e) {
11 System.err.println ("Transaction failed, rolling back. Error: ");
12 printSQLErrorMessage (e); // custom function 
13 try {
14 conn rollback () conn.rollback ();
15 conn.setAutoCommit (true);
16 }
17 catch (SQLException er) {
18 System.err.println ("Roll back failed. Error: ");
19 printSQLErrorMessage (er); // custom function 
20 }
21 }
```
```
在幻燈片的示例中： 
• 在第 2 行中，Connector/J 通過使用 .setAutoCommit(false) 禁用自動提交來啟動事務。
• 在第 4 行和第 5 行，程序執行兩個 INSERT 語句。 如果成功，則更改將通過第 7 行中的 commit() 方法持久保存到數據庫中。
• 如果第一個 try 塊中的任一 INSERT 語句失敗，程序將引發異常，該異常在第 10 行被捕獲。
• 程序顯示一條消息並嘗試使用第 14 行的 rollback() 方法進行回滾。它還重新啟用自動提交模式。
• 回滾本身在第二個 try 塊內執行，因此如果失敗，則會引發異常並在第 17 行捕獲
```

## 在連接器/Python 中編寫事務性語句
```
01 try:
02 cursor = conn.cursor()
03 cursor.execute("UPDATE Country SET GNP = (GNP * 1.1) 
WHERE Name = 'Armenia'")
04 cursor.execute("UPDATE Country SET GNP = (GNP * 1.1) 
WHERE Name = 'Bermuda'")
05 cursor.close()
06 conn.commit()
07 except mysql.connector.Error as e:
08 print("Transaction failed, rolling back. Error was:")
09 print(e)
10 try:
11 conn.rollback()
12 except mysql.connector.Error as er:
13 print("Unable to roll back. Error was:")
14 print(er)
```
```
在幻燈片的示例中： • 默認情況下，連接器/Python 禁用自動提交，因此無需顯式啟動事務。 可以通過將 autocommit=false 傳遞給 版權所有 © 2017，Oracle 和/或其附屬公司來啟用自動提交。 版權所有。
yp g connect() 方法在最初建立連接時。 如果禁用自動提交，則必須使用 conn.start_transaction() 啟動事務。
• 在第 3 行和第 4 行，程序執行兩個 INSERT 語句。 如果它們成功，則更改將通過第 6 行中的 commit() 方法持久保存到數據庫中。
• 如果第一個 try 塊中的任一 INSERT 語句失敗，程序將引發異常，該異常在第 7 行中被捕獲。
• 程序顯示一條消息並嘗試使用第 11 行的 rollback() 方法進行回滾。
• 回滾本身在第二個 try 塊中執行，因此如果失敗，則會引發異常並在第 12 行捕獲
```

## 一致性問題
當多個客戶端同時訪問同一個表中的數據時，可能會出現以下一致性問題： 
• 髒讀：當一個事務讀取另一個未提交事務所做的更改時，會發生臟讀。
• 不可重複讀：當同一個讀操作在同一事務中稍後重複時產生不同的結果時，就會發生不可重複讀。
• 幻讀：幻讀是之前在同一事務中不可見的一行。
```
臟讀示例 
假設事務 T1 修改了一行。 如果事務 T2 讀取該行並看到修改，即使 T1 尚未提交它，那就是臟讀。 如果 T1 回滾，則即使 T1 沒有提交修改，那也是臟讀。 如果 T1 回滾，更改將被撤消，但 T2 不知道。
不可重複讀取的示例 
假設事務 T1 讀取一些行。 然後，第二個事務 T2 更改其中一些行並提交更改。 如果 T1 能夠在再次檢索行時看到事務 T2 中所做的更改，則證明初始讀取是不可重複的。
這是一個問題，因為 T1 不會從同一事務中的同一查詢獲得一致的結果。
幻讀示例 
假設事務 T1 和 T2 開始，T1 讀取一些行。 如果 T2 插入新行並且 T1 在重複相同的讀取操作時看到該行，則稱為幻讀（新行即為幻讀）。
```

## 臟讀：示例
![[Pasted image 20211217105400.png]]
S在幻燈片的示例中：
```
• 事務 A 將 ItemsInStock 的值更新為 4 以反映客戶購買。
然後它開始計費過程。
 • 當事務A 仍在進行中時，事務B 開始。 它讀取 ItemsInStock 值，該值在讀取發生時為 4。
• 事務 A 然後失敗，因為客戶的付款被拒絕並且 ItemsInStock 回滾到其原始值 5。但是，事務 B 是在 ItemsInStock 的值為 4 的基礎上工作的。
事務 B 從另一個事務中讀取了未提交的更改。 這被稱為“臟讀”。
```

## 不可重複讀：示例
![[Pasted image 20211217105859.png]]
在幻燈片中的示例中： 
• 事務 A 首先啟動並讀取 ItemsInStock 的值，該值在讀取發生時為 5。
• 事務A 做了一些工作。 當事務 A 繁忙時，事務 B 啟動並將 ItemsInStock 的值更新為 4。
• 事務 A 然後再次讀取 ItemsInStock 的值，現在是 4。
事務 A 已讀取 ItemsInStock 列兩次，每次都收到不同的結果。 這稱為“不可重複讀取”。

## 幻讀：示例
![[Pasted image 20211217110133.png]]
```
在幻燈片的示例中： 
• 事務 A 啟動並查詢庫存表，檢索類型列中值為“ABC123”的所有項目。 查詢返回三行。
 • 事務A 然後執行其他任務。
• 當事務A 忙時，事務B 啟動並向庫存表中插入一個新行，其類型列中的值為“ABC123”。
• 事務B 重新發出步驟1 中的查詢。這次查詢返回四行。
事務 A 在同一個事務中兩次查詢了庫存表，並且每次都檢索了不同數量的行。 這稱為每次不同的行數。 這被稱為“幻讀”。 幻讀。”
```

## 隔離級別
隔離級別控制事務所做的更改如何影響同時發生的其他事務。 這是通過多版本化實現的。
• READ UNCOMMITTED 允許事務查看其他事務所做的未提交更改 其他事務所做的未提交更改。
• READ COMMITTED 允許事務僅在其他事務已提交時查看其他事務所做的更改。
• REPEATABLE READ（默認值）確保如果一個事務兩次發出相同的 SELECT 查詢，無論其他事務是否已提交或未提交的更改，它都會獲得相同的結果。
• SERIALIZABLE 將一項事務的影響與另一項事務的影響完全隔離。
```
隔離級別僅影響同時執行的事務。 事務提交後，其更改對任何後續事務都可見。
閱讀未提交
READ UNCOMMITTED 允許臟讀、不可重複讀和幻讀發生 
READ COMMITTED 
未提交的更改保持不可見。 此隔離級別允許發生不可重複讀取和幻像。
REPEATABLE READ 
確保同一查詢的不同執行結果一致。  REPEATABLE READ 隔離級別允許幻讀，這意味著如果另一個事務在兩個 SELECT 語句之間插入新行，則第二個 SELECT 會看到新行
SERIALIZABLE 
SERIALIZABLE 類似於 REPEATABLE READ，但有一個附加限制，即一個事務選擇的行在第一個事務完全完成之前不能被另一個事務更改。  REPEATABLE READ 和 SERIALIZABLE 之間的本質區別在於，對於 REPEATABLE READ，一個事務不能修改另一個已修改的行，而對於 SERIALIZABLE，如果另一個事務只是讀取了行，則一個事務不能修改行

多版本 InnoDB 保留有關已更改行的舊版本的信息，以支持事務功能，例如並發和回滾。 這稱為多版本。
使用多版本，每個事務都會看到適合其隔離級別的數據庫內容視圖。
例如，隔離級別為 REPEATABLE READ 時，事務會在第一次讀取時看到數據庫狀態的快照。 這種隔離級別的一個特性是它提供了一致的讀取：在事務期間的不同時間發出相同的 SELECT 語句會產生相同的結果。 交易看到的唯一變化是它自己做出的變化，而不是其他交易自己做出的變化，而不是其他交易做出的變化。
或者，對於 READ COMMITTED，行為略有不同。 事務會看到在每次讀取時更新的數據庫視圖。 事務能夠看到自上次讀取以來其他事務所做的提交結果
```
## 解決隔離級別的一致性問題
下表顯示了每個隔離級別可能存在哪些一致性問題
![[Pasted image 20211217115143.png]]
* 默認隔離級別是可重複讀。

## 設置隔離級別
事務隔離級別是您可以在啟動時設置的服務器選項，或者作為會話或全局選項
• 在選項文件中：
```
[mysqld]
transaction-isolation = READ-COMMITTED
```
• 在會話中：
```
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```
• 全局更改隔離級別，直到下一次服務器啟動：
```
SET GLOBAL TRANSACTION GLOBAL TRANSACTION ISOLATION ISOLATION LEVEL READ LEVEL READ COMMITTED COMMITTED;
```

```
任何客戶端都可以為自己的會話修改事務隔離級別； 但是，全局更改默認事務隔離級別需要 SUPER 權限。
全局設置默認事務隔離級別適用於所有新客戶端連接全局設置默認事務隔離級別適用於從那時起建立的所有新客戶端連接。 現有連接不受影響。
```

## 顯示當前隔離級別
檢查 tx_isolation 服務器變量的值
• @@session.tx_isolation 或 @@session.tx_isolation：當前連接的隔離級別
• @@global.tx_isolation: 到服務器的所有連接的隔離級別 
• 示例，使用會話隔離級別：
![[Pasted image 20211217120043.png]]
```
@@tx_isolation 變量包含會話事務隔離級別，與@@session.tx_isolation 相同。 使用@@global.tx_isolation 變量獲取全局隔離級別
```
## 鎖定
鎖定可以防止兩個或多個客戶端同時訪問相同數據時出現的問題。
• 鎖允許持有鎖的客戶端訪問數據，但限制其他客戶端可以使用該數據執行的操作。
• MySQL 支持兩種類型的鎖： 
– 共享：如果一個客戶端想要讀取數據，其他想要讀取相同數據的客戶端不會產生衝突，它們都可以同時讀取。 但是，另一個想要寫入（修改）數據的客戶端必須等到讀取完成。
– 獨占：如果一個客戶端要寫入數據，所有其他客戶端都必須 如果一個客戶端要寫入數據，所有其他客戶端必須等到寫入完成後才能讀取或寫入。

```
鎖由服務器管理。 它代表一個客戶端鎖定數據以限制其他客戶端對數據的訪問，直到鎖定被釋放。 鎖定機制的作用是序列化對數據的訪問。 當多個客戶想要對同一數據進行更改時，每個客戶均 版權所有 © 2017，Oracle 和/或其附屬公司。 版權所有。
必須等待輪到它。
共享鎖和排他鎖控制鎖定的範圍，這取決於客戶端是讀取還是寫入數據。 一個讀者必須阻止作者，而不是其他讀者。 寫入器必須同時阻止讀取器和寫入器。 讀鎖和寫鎖允許強制執行這些限制。 鎖定使客戶端等待訪問，直到他們可以安全繼續。 通過這種方式，鎖通過防止客戶端與其他客戶端同時進行沖突更改以及讀取正在與其他客戶端同時更改的數據以及讀取正在更改的數據來防止數據損壞 被改變的。
```

## 鎖定讀取
MySQL 有兩個鎖定修飾符，您可以將它們添加到 SELECT 語句的末尾：
• LOCK IN SHARE MODE：該子句使用共享鎖鎖定每個選定的行。 這意味著沒有其他事務可以使用獨占鎖，但其他事務可以使用共享獲取獨占鎖，而其他事務可以使用共享鎖。 因為讀操作不鎖定行，所以它們不受鎖定的影響。
• FOR UPDATE：該子句使用排他鎖鎖定每個選定的行。 它阻止其他人獲取行上的任何鎖，但允許讀取行和行，但允許讀取行
```
使用 REPEATABLE READ 隔離級別，您可以使用 SELECT...LOCK IN SHARE MODE 操作來強制其他事務在他們想要修改所選行時等待您的事務完成。 這類似於在 SERIALIZABLE 隔離區進行操作。級別，它隱式地將 LOCK IN SHARE MODE 添加到沒有顯式鎖定修飾符的 SELECT 語句。 如果 SELECT 語句處理已被另一個未提交事務修改的行，則 LOCK IN SHARE MODE 鎖定 SELECT 操作，直到該事務提交。
例如，您可以發出 SELECT 語句，根據其結果做出決定，然後執行 INSERT 語句，確保在您對用於做出決定的行採取行動之前，沒有其他客戶端可以更改您用於做出決定的行 在你採取行動之前。
FOR UPDATE 子句提供了一個類似的功能，在語句之間鎖定數據，以便您以後可以安全地修改數據，因為它沒有更改
```
 ## SELECT...LOCK IN SHARE MODE：示例
 • 問題：在世界數據庫中添加一個新的澳大利亞城市： 
 1. 您發出一個 SELECT 查詢來驗證澳大利亞 (AUS) 的國家代碼是否存在於 Country 表中。
2. 您在您在 City 表中插入新行的國家代碼為 AUS 的表中插入新行。
3. 在插入新的城市行之前，另一個用戶從國家表中刪除了 AUS。
4. 您的 City 行現在是孤立的，因為它的父國家不再存在。
• 解決方案：使用LOCK IN SHARE MODE 執行Country 表的初始SELECT
![[Pasted image 20211217120422.png]]
```
使用 LOCK IN SHARE MODE 時，事務讀取最新的可用數據並在它讀取的行上設置共享模式鎖。 其他會話可以讀取這些行，但在您的事務提交之前無法修改它們。 查詢 Country 表後返回代碼AUS，您可以安全地將子記錄添加到 City 表並提交事務。
```

## SELECT...FOR UPDATE：示例
• 問題：您在名為 CityCodes 的表中手動維護一個整數計數器列，您可以使用該列為添加到 City 表中的每個城市分配一個唯一標識符。
– 要計算下一個可用代碼，您讀取當前代碼並將其值加 1，然後將其值加 1。
– 在並發環境中，兩個客戶端可以同時檢索計數器的相同值並使用該值構建序列中的下一個代碼，從而導致重複鍵錯誤。
• 解決方案：使用 FOR UPDATE 執行 CityCodes 表的初始 SELECT：
![[Pasted image 20211217120546.png]]
```
FOR UPDATE 子句提供了一個類似於 LOCK IN SHARE MODE 的功能，在語句之間鎖定數據，以便您以後可以安全地修改數據，因為它沒有更改過。  SELECT...FOR UPDATE 語句讀取最新的可用數據，以與 SQL UPDATE 語句相同的方式在它讀取的每一行上設置排他鎖。
注意：幻燈片中的示例僅演示了 SELECT...FOR UPDATE 的工作原理。 在 MySQL 中，您可以通過僅訪問一次表來生成唯一標識符： UPDATE CityCodes SET counter_field = LAST_INSERT_ID(counter_field + 1); 選擇 LAST_INSERT_ID(); 本示例中的 SELECT 語句僅檢索標識符信息（特定於當前連接）。 它不訪問任何表
```

## 總結 
在本課中，您應該已經學會瞭如何：
• 使用事務並發執行多條 SQL 語句 
• 定義和使用 ACID 事務規則 
• 描述執行並發語句可能導致的一致性問題 
• 將一個事務與另一個事務隔離 
• 應用讀取 鎖定以確保更新期間讀取的一致性

