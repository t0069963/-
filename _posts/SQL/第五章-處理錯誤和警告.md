## 目標 
完成本課後，您應該能夠： 
• 設置 SQL 模式以影響錯誤輸出 
• 解釋錯誤消息 
• 使用 SHOW WARNINGS 和 SHOW ERRORS 語句 
• 檢查 MySQL 診斷信息
• 使用 perror 實用程序檢索錯誤詳細信息 
• 處理 使用連接器編碼時出錯

## 議程 
• SQL 模式 
• 解釋錯誤和警告 
• MySQL 診斷 
•使用連接器處理錯誤和異常

## SQL 模式 
SQL 模式影響 MySQL 支持的 SQL 語法和它執行的數據驗證檢查。
• SQL 模式使用 sql_mode 變量設置： 
– 通過使用 --sql-mode 命令行選項啟動 mysqld，或通過在選項文件中設置 sql-mode 選項 
– 通過設置 使用 SET 運行時的 sql_mode 變量 
• SQL 模式存在於全局級別和會話級別。
– 默認情況下，新會話使用全局 SQL 模式。
– 所有用戶都可以更改自己的會話 SQL 模式。– 更改全局 SQL 模式需要 SUPER 權限。
```
您可以通過在啟動 mysqld 時在命令行中設置選項 --sql-mode="mode_value" 來設置默認 SQL 模式： shell> mysqld --sql-mode="ANSI" 或者，您可以將 sql-mode="mode_value" 選項添加到選項文件中的 [mysqld] 或 [server] 組。
使用以下語句檢索當前的全局 SQL 模式：mysql> SELECT @@global.sql_mode; 要獲取當前會話的 SQL 模式，請使用以下語句： mysql SELECT @@ mysql> SELECT @@session sql mode session.sql_mode; 您還可以使用簡寫變量名稱@@sql_mode 檢索會話 SQL 模式： mysql> SELECT @@sql_mode\G ************************* ** 1.行*************************** 
@@sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,E RROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
```

## 設置 SQL 模式 
sql_mode 變量值可以是一個空字符串、一個 SQL 模式的名稱或多個以逗號分隔的 SQL 模式名稱。
• 如果值為空或包含多個模式名稱，則必須引用必須引用。
• 如果值包含單個模式名稱，則引用是可選的。
• 如果 GLOBAL 或 SESSION 均未指定，則默認值為 SESSION。
• SQL 模式值不區分大小寫。例子：
mysql> SET sql_mode = ''; 
mysql> SET sql_mode = ANSI_QUOTES; 
mysql> SET GLOBAL.sql_mode = 'IGNORE_SPACE,ANSI_QUOTES'; 
```
設置全局變量指定所有後續客戶端連接的默認 SQL 模式。 設置會話變量只影響當前客戶端，直到它斷開連接。
任何客戶端都可以隨時更改自己的會話 sql_mode 值。 如果 GLOBAL 或 指定SESSION，默認為SESSION。
某些 SQL 模式值是啟用一組模式的組合模式。 此類別中的值包括 ANSI 和 TRADITIONAL。 要查看組合模式包含哪些模式，請在設置後檢索該值：
mysql> set sql_mode=TRADITIONAL; Query OK 0 rows affected (# ## sec) Query OK, 0 rows affected (.
# sec) mysql> select @@sql_mode\G *************************** 1. row *************************** @@sql_mode STRICT_TRANS_TABLES, STRICT_ALL_TABLES, NO_ZERO_IN_DATE, NO_ZERO_DATE,  ERROR_FOR_DIVISION_BY_ZERO, NO_AUTO_CREATE_USER, NO_ENGINE_SUBSTITUTION 1 row in set (.
# sec)
```
## 默認 SQL 模式
• 使用以下方式顯示當前 SQL 模式：
SELECT @@GLOBAL.sql_mode; 
SELECT @@SESSION.sql_mode; 
• 默認的 SQL 模式是：
```
mysql> SELECT @@sql_mode\G ****************** 1. row ******************* @@sql_mode:  ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE, NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO ENGINE SUBSTITUTION
1 row in set (##.# sec) 
```
• 默認情況下，當前會話的SQL 模式與全局SQL 模式相同。
```
MySQL 5.7.12 中的默認 SQL 模式顯示在幻燈片中。
在 MySQL 5.7.5 中添加了 ONLY_FULL_GROUP_BY 和 STRICT_TRANS_TABLES 模式。 MySQL 5.7.7 添加了 NO AUTO CREATE USER 模式。
5.7.5. MySQL 5.7.7 添加了 NO_AUTO_CREATE_USER 模式。 MySQL 5.7.8 中添加了 ERROR_FOR_DIVISION_BY_ZERO、NO_ZERO_DATE 和 NO_ZERO_IN_DATE 模式。
STRICT_TRANS_TABLES 的存在意味著 MySQL 默認處於嚴格模式。
下一張幻燈片描述了啟用嚴格模式和 NO_ENGINE_SUBSTITUTION 的效果
```
## 嚴格模式 
MySQL 在啟用 STRICT_TRANS_TABLES 或 STRICT_ALL_TABLES 時處於嚴格模式。
• 未啟用嚴格模式時，MySQL 會轉換對錶條件無效的值。
–  轉換現有數據時： 
— INSERT、REPLACE、UPDATE 和 LOAD DATA INFILE 
— 使用 ALTER TABLE 更改包含數據的列 
— 在列中指定 DEFAULT 值 
— MySQL 將無效值調整為最接近的有效值 MySQL 將無效值調整為最接近的有效值。
— 超出範圍、NULL 或錯誤類型的值 
— 生成警告，您可以使用 SHOW WARNINGS 查看 
• 在嚴格模式下，MySQL 生成錯誤併中止語句。
```
MySQL 在提供無效數據時通常比許多傳統數據庫系統更寬容。 例如，如果您將負值寫入 UNSIGNED 列，MySQL 會將其轉換為零，這是該列數據類型的最接近的合法值模式，服務器拒絕超出範圍、數據類型不正確或沒有默認值的列丟失的值。當您在使用事務表（例如使用默認存儲引擎 InnoDB 創建的表）並且啟用 STRICT_TRANS_TABLES 時生成錯誤，語句將中止。對於非事務表，如果錯誤發生在插入操作的第一行（或第一行），MySQL 將中止語句。 如果在第二次或以後的插入中發生錯誤，MySQL 會將任何無效值調整為合法值，然後插入，並且僅生成警告。 這是因為較早的插入是成功的。STRICT_ALL_TABLES 類似於 STRICT_TRANS_TABLES，但對於非事務性表，即使多行插入的第二行或後面的行中出現錯誤，也會導致語句中止。這可能會導致部分更新。 為了在使用 STRICT_ALL_TABLES 時避免這種情況，您必須使用可以在不更改表的情況下中止的單行語句。注意：本課程在標題為“事務”的課程中涵蓋事務處理。

```

 ## NO_ENGINE_SUBSTITUTION SQL 模式 
 NO_ENGINE_SUBSTITUTION SQL 模式控制在諸如 CREATE TABLE 或 ALTER TABLE 之類的語句指定不可用的存儲引擎時發生的情況。
• 啟用時，發生錯誤並且 CREATE TABLE 或 ALTER TABLE ALTER TABLE 語句失敗 語句失敗 
• 如果禁用 NO_ENGINE_SUBSTITUTION 且引擎不可用：
– 對於 CREATE TABLE，MySQL 使用默認引擎創建表，並發出警告 .
– 對於 ALTER TABLE ALTER TABLE，MySQL 引發警告並且表是 MySQL 引發警告並且表未更改。
```
 InnoDB 是默認的存儲引擎，是大多數情況下的最佳選擇。 NO_ENGINE_SUBSTITUTION SQL 模式決定了當您嘗試使用 MySQL 實例中不可用的存儲引擎創建表時會發生什麼
```

## 其他重要的 SQL 模式 
其他重要的 SQL 模式包括： 
• ANSI：更改語法和行為以更好地符合標準 SQL。 它包括以下模式：REAL_AS_FLOAT、PIPES_AS_CONCAT、ANSI_QUOTES、IGNORE SPACE、IGNORE_SPACE 和 ONLY FULL GROUP B ONLY_FULL_GROUP_BY 
• TRADITIONAL：使 MySQL 的行為更像“傳統”SQL 數據庫系統，在向列中插入不正確的值時引發錯誤而不是警告 . 它包括：STRICT_TRANS_TABLES、STRICT_ALL_TABLES、NO ZERO IN DATE _ __ 、NO ZERO DATE _ _ 、ERROR_FOR_DIVISION_BY_ZERO、NO_AUTO_CREATE_USER 和 NO_ENGINE_SUBSTITUTION。
• ONLY_FULL_GROUP_BY：當SELECT 列表引用不在GROUP BY 子句中的列時，不允許進行查詢
```
組合模式 ANSI 和 TRADITIONAL SQL 模式是 MySQL 中啟用多種模式的幾種組合模式之一。
ANSI 模式 一些模式改變了語法的處理方式，ANSI 模式包含其中的幾種模式。 默認情況下，MySQL 內置函數不是保留字，因此即使有 COUNT() 函數，您也可以創建名為 count 的列。  “(”字符必須緊跟在名稱“COUNT”之後以將其標識為函數。IGNORE_SPACE SQL 模式允許函數名稱和“(”字符之間有空格。這會導致內置函數名稱被視為保留字 . 因此，必須將與函數名相同的列名等標識符放在引號中。默認情況下，標識符引號是反引號(`)，但ANSI_QUOTES SQL 模式允許使用雙引號("  ) 出於同樣的目的。
兼容模式 一些組合模式提高了與舊版本 MySQL 或其他數據庫系統的兼容性，包括數據庫系統。 其中包括 MYSQL40 DB2 MSSQL MYSQL40、DB2、MSSQL 和 ORACLE
單一行為模式 大多數 SQL 模式改變單一行為。 其中包括： • ONLY_FULL_GROUP_BY，拒絕任何查詢，其中選擇列表、HAVING 條件或條件或 ORDER BY ORDER BY 列表引用列表引用未在 GROUP BY 子句中命名的列中未命名的非聚合非聚合列 並且在功能上不依賴於 GROUP BY 列。 它還排除在 HAVING 子句中使用列別名。• NO_ZERO_DATE，它不允許 MySQL 通常允許的諸如“0000-00-00”之類的日期，即使在嚴格模式下也是如此。
• ERROR_FOR_DIVISION_BY_ZERO，它會引發錯誤併中止任何試圖將值除以零的語句。 未啟用此模式時，MySQL 將除以零評估為 NULL 並引發警告。
注意：有關服務器 SQL 模式的完整列表，請參閱：https://dev.mysql.com/doc/mysql/en/sql mode.html。
```

## 使用 SHOW WARNINGS 
當 MySQL Server 不能完全滿足請求或操作可能會產生意外副作用時，它會生成警告。
• SHOW WARNINGS 顯示由最後一條語句產生的警告 這些被後續語句覆蓋。 這些被後續的非診斷語句覆蓋。  “級別”列指示嚴重性： 
– 錯誤、警告或註意 • SELECT COUNT(*) WARNINGS 或 SELECT @@warning count warning_count 顯示警告數 顯示警告數。
• SHOW WARNINGS LIMIT 1,1 僅顯示第二個警告。
– 帶有偏移量的 LIMIT 子句允許您“滾動”結果。
```
一個語句生成的警告僅在服務器處理另一條非診斷語句時被覆蓋之前才可從服務器獲得。 因此，如果需要查看警告，必須在警告產生後立即查詢。
SHOW COUNT(*) WARNINGS 和 SELECT @@warning_count 都顯示錯誤、警告和註釋的總數。 這些語句的不同之處在於，第一個被認為是診斷語句並且不清除消息列表。 第二個，因為它包含一個 SELECT，不是一個診斷語句並且（從 MySQL 5.7.2 開始）確實清除了消息列表。
“警告”出現在多個嚴重級別： • 錯誤消息表示阻止服務器完成請求的嚴重問題。
• 警告消息指示服務器可以繼續處理請求的問題。
• 註釋消息僅供參考。
要抑制 Note 警告的生成，您可以將 sql_notes 系統變量設置為零：mysql> SET sql_notes = 0;
```

## 此會話演示如何與服務器交互以顯示有關警告的信息。
SHOW ERRORS 語句類似於 SHOW WARNINGS，但顯示級別值為 Error 的消息。
• SHOW ERRORS 產生的輸出往往比SHOW WARNINGS 少。
mysql> SELECT CONVERT(3, DECIMAL(1,1)), ABS('a');
![[Pasted image 20211219020143.png]]
mysql> SHOW COUNT(*) WARNINGS;
![[Pasted image 20211219020337.png]]
mysql> SHOW WARNINGS\G
![[Pasted image 20211219020413.png]]
mysql> SHOW WARNINGS LIMIT 1,1;
![[Pasted image 20211219020534.png]]
mysql> SELECT a FROM nothing;
ERROR 1146 (42S02): Table 'sakila.nothing' doesn't exist
mysql> SHOW WARNINGS;
![[Pasted image 20211219020626.png]]

## 使用顯示錯誤
SHOW ERRORS 語句類似於 SHOW WARNINGS，但顯示級別值為 Error 的消息。
• SHOW ERRORS 產生的輸出往往比SHOW WARNINGS 少。
![[Pasted image 20211219020949.png]]
• SHOW ERRORS 支持與顯示錯誤支持與顯示警告相同的功能：
– SHOW COUNT(*) ERRORS;
– SELECT @@error_count;
– SHOW ERRORS LIMIT 1,1;
```
max_error_count 系統變量控制服務器為其存儲信息的錯誤、警告和註釋消息的最大數量，因此顯示顯示警告或顯示錯誤顯示的消息數量。 要更改消息數量，服務器可以存儲、更改 max_error_count 的值。 默認值為 64。
注意：max_error_count 的值還限制了診斷區域中條件區域的數量，這將在本課後面介紹。
```
## 使用 perror 調查錯誤代碼
perror 程序的目的是向您顯示有關 MySQL 在發生錯誤或警告時使用的錯誤代碼的信息。
• perror 包含在 MySQL 發行版中。
• 使用 perror ti d o 檢查錯誤代碼。
![[Pasted image 20211219021712.png]]
• 此錯誤消息表明MySQL 無法寫入table.frm 文件。 您可以在 shell 中使用 perror 來找出 : 無法創建/寫入文件 
為什麼：
![[Pasted image 20211219021911.png]]
MySQL 在無法成功執行語句時會引發錯誤和警告。 錯誤可能由 MySQL 引發，也可能由操作系統引發。
幻燈片顯示了一個操作系統錯誤示例：CREATE TABLE 語句 該幻燈片顯示了操作系統錯誤的示例：CREATE TABLE 語句無法寫入文件系統。 程序無法寫入文件系統的原因有多種，如果沒有進一步的信息，您不知道是什麼原因。 這可能是由於磁盤已滿、文件系統權限問題、網絡連接問題或其他一些錯誤。
要找出問題所在，請運行 perror 程序，傳入錯誤消息中的 Errcode 編號。 在這種情況下，perror 會顯示一條消息，指示文件系統的 M SQL t it t th t 文件權限不允許 MySQL 寫入該文件。

## 使用 MySQL 診斷
SQL 語句生成填充診斷區域的診斷信息。 診斷區域包含兩種類型的診斷信息：
• 語句信息
– NUMBER:具有信息的條件區域的數量。
– ROW_COUNT：語句影響的行數
• 狀況信息。 條件包括： – RETURNED_SQLSTATE：指示條件的 SQLSTATE 值的字符串。
– MESSAGE_TEXT：指示條件錯誤消息的字符串。
– MYSQL_ERRNO：一個整數，指示條件的 MySQL 錯誤代碼。
```
GET DIAGNOSTICS 語句使開發人員可以輕鬆地在運行時檢查錯誤代碼。
對於生成兩個診斷條件的語句，診斷區域顯示如下：
```
![[Pasted image 20211219022819.png]]
```
注意：有關診斷條件的完整列表，請參閱有關診斷條件的完整列表，請參閱 MySQL 參考手冊 MySQL 參考手冊：http://dev.mysql.com/doc/mysql/en/diagnostics-area.html。
注意：大多數非診斷 SQL 語句會自動填充診斷區域。
存儲例程還可以使用 SIGNAL 和 RESIGNAL 語句顯式設置診斷區域的內容。 本課程將 RESIGNAL 和 SIGNAL 作為“存儲例程”課程中討論的存儲例程中的錯誤處理的一部分。
```
## 檢索診斷信息
• 使用SHOW WARNINGS 或SHOW ERRORS 檢索診斷區域中的警告或錯誤消息。
• 使用GET DIAGNOSTICS 檢索語句或條件信息。
– 語句信息：檢索受影響的條件和行數。
```
GET DIAGNOSTICS @p1 = NUMBER, @p2 = ROW_COUNT;
```
– 條件信息：指定條件編號並將所需條件項存儲在變量中。
```
GET DIAGNOSTICS CONDITION 1 @p3 = RETURNED SQLSTATE @p4 = GET DIAGNOSTICS CONDITION 1 @p3 = RETURNED_SQLSTATE, @p4 =
MESSAGE_TEXT;
```
```
GET DIAGNOSTICS 語句是標準 SQL 的 MySQL 擴展。 它通常出現在存儲程序的錯誤處理程序中，但您可以在此上下文之外使用它來檢查任何 SQL 語句的執行情況。
```
## 示例：檢索診斷信息
![[Pasted image 20211219023838.png]]
```
幻燈片中的示例演示瞭如何在您嘗試刪除不存在的表時檢查診斷信息。
```

## 使用連接器時處理錯誤
• Connector/J：使用Exception 框架，特別是java.sql.SQLException 類。
– Connector/J JDBC 驅動程序使用 MySQL 錯誤代碼、SQLSTATE 和錯誤消息填充 SQLException 的實例。
• PHP/PDO：指定錯誤處理模式。
– 使用默認的靜默錯誤處理模式 (PDO::ERRMODE_SILENT) 
– 使用警告策略引發 E_WARNINGs 而不是錯誤 (PDO::ERRMODE_WARNING) 
– 通過 PDOException 類使用異常處理和訪問錯誤信息 (PDO::ERRMODE_EXCEPTION)
• 連接器/Python：使用標準Python 異常處理。
– mysql.connector.Error 類具有 errno、sqlstate 和 msg 屬性
```
以交互方式使用 mysql 時，當您執行的代碼生成警告或錯誤時，您會立即獲得反饋。 使用連接器編碼時，您必須依賴編程語言和特定連接器的特性。
版權所有 © 2017，Oracle 和/或其附屬公司。 版權所有。
每個連接器通過其驅動程序類向語言提供診斷信息。 您可以通過查詢驅動程序提供的元素來訪問錯誤號、SQLSTATE 和錯誤消息等信息。 每個連接器都使用其設計語言的特性。 這些功能包括異常類、try 和 catch 塊以及對象屬性。
使用以下 PHP 語法在 PDO_MySQL 中設置錯誤處理模式：
$pdo->setAttribute(PDO::ATTR_ERRMODE, error_mode)
```

## 連接器/J：SQLException 類
Java SQLException 類表示使用 Connector/J 連接或執行語句時引發的錯誤。
• 當查詢或連接嘗試在 try{} 塊中失敗時，Java 會拋出一個 SQLException 實例。
• 控制立即傳遞給相關的catch b k oc 。
– 具體來說，第一個接受 SQLException 或超類的 catch 塊 • SQLException 實例提供允許您檢查 catch 塊中的錯誤的方法。
- 這些包括：
— getErrorCode()：返回 MySQL 錯誤代碼
— getSQLState()：返回 SQLSTATE 代碼
— getMessage()：返回錯誤信息的文本
Connector/J 以標準 Java 方式處理 MySQL 錯誤，即： 
• 通過要求您將 SQL 連接和查詢代碼放在 try{} 塊中 
• 通過在 MySQL 引發錯誤時引發 Java 異常 通過在 MySQL 引發錯誤時引發 Java 異常 
- MySQL 警告不會引發異常。
- SQL 模式會影響 MySQL 是否針對每種類型的問題陳述引發警告或錯誤。
異常類型取決於問題的類型。
• 在連接嘗試期間拋出的 ClassNotFoundException 表示連接找不到 MySQL Connector/J 驅動程序類連接找不到 MySQL Connector/J 驅動程序類。
• SQLException 表示 MySQL 識別出的執行問題，例如語法錯誤、權限問題或無效的數據庫或表名

## 示例：SQLException
• 示例代碼：
```
01 private void missingTable() {
02 try {
03 Connection c = DriverManager.getConnection(
04 "jdbc:mysql://localhost/world", "user", "password");
05 Statement s = c.createStatement();
06 ResultSet rs = s.executeQuery("select * from no_such_table");
07 }
08 catch(SQLException e) {
09 System.out.println("SQL Exception code: " + e.getErrorCode());
10 System.out.println("SQL Exception state: " + e.getSQLState());
11 System.out.println("SQL Exception text: " + e.getMessage());
12 }
13 }
```
• 輸出 ：
```
SQL Exception code: 1146
SQL Exception state: 42S02
SQL Exception text: Table 'world.no_such_table' doesn't exist
```
```
當程序嘗試對不存在的表執行查詢時，它在第 6 行中引發錯誤。 該錯誤立即在第 8 行的 catch 塊中捕獲，並在第 9-11 行詢問傳遞給它的 SQLException 對像以生成有意義的錯誤報告。
幻燈片中代碼的輸出包含 MySQL 錯誤代碼、SQLSTATE 和中止查詢嘗試產生的錯誤消息。
```

## PHP：mysqli 錯誤處理函數 
mysqli 類有幾個用於檢查錯誤的有用屬性。
• ``$errno``、``$sqlstate`` 和``$error`` 屬性分別包含MySQL 錯誤號、SQLSTATE 值和錯誤文本。
• ``$error_list`` 屬性包含錯誤數組。 每個錯誤都在一個關聯數組中，並包含 ``$errno``、``$sqlstate`` 和 ``$error`` 屬性。
• ``$connect_errno`` 和``$connect_error`` 包含與連接期間的最後一個錯誤相關聯的數字和文本。
• ``$warning_count`` 給出了最後執行的語句的警告次數
```
mysqli::$info 屬性是一個字符串，其中包含您在 mysql 命令行客戶端中以交互方式運行查詢後可能會看到的信息。
示例：
記錄：100 重複：0 警告：0 mysqli::get_warnings() 函數返回類 mysqli_warning 的實例，其中包含屬性 errno、sqlstate 和消息。
```
## 示例：mysqli 錯誤處理
例如，使用 mysqli 類屬性報告異常：
```
01 $sql="SELECT CONVERT(3, DECIMAL(1,1)), ABS('a')";
02 echo "Running statement: $sql\n"; 
03 $res = $mysqli->query($sql);
04 echo "Number of warnings: " 
05 . $mysqli->warning count . "\n\n";

06 $sql = "SELECT a FROM nothing";
07 echo "Running statement: $sql\n"; 
08 $res = $mysqli->query($sql);
09 echo "Error number: " . $mysqli->errno . "\n";
10 echo "Error message: " . $mysqli->error . "\n";
```
• Output:
```
Running statement: SELECT CONVERT(3, DECIMAL(1,1)), ABS('a')
Number of warnings: 2
Running statement: SELECT a FROM nothing
Error number: 1146
Error message: Table 'world.nothing' doesn't exist
```
```
使用前面幻燈片中的 MySQL 代碼，此示例從第一個查詢（第 1 行）生成兩個警告，並從第二個查詢（第 6 行）生成一個錯誤。
```

## PHP：mysqli_sql_exception 類 
mysqli 驅動程序在使用 mysqli_report() 函數進行配置時，以及當 MySQL 代碼導致錯誤時拋出 mysqli_sql_exception。
• mysqli_sql_exception 類包含以下屬性： 
– code、sqlstate 和message，分別表示MySQL 錯誤號、SQLSTATE 值和錯誤文本。
– 文件和行，它允許您查明包含錯誤的代碼行。 包含錯誤。
• 使用提供的getter 方法訪問這些屬性：
– getCode()、getMessage()、getFile()、getLine() 
– sqlstate 沒有getter 方法。 直接訪問該屬性。
```
mysqli_report() 函數允許您指定是否為警告或錯誤拋出 mysqli_sql_exception。
• mysqli 報告（MYSQLI REPORT STRICT）：這會引發
mysqli_sql_exception 當 MySQL 語句或通過 mysqli 連接時發生錯誤。
• mysqli_report(MYSQLI_REPORT_ALL)：這會針對所有警告、錯誤和索引通知拋出一個mysqli_sql_exception。
mysqli_report() 的參數是位掩碼，因此您可以通過執行以下操作導致為錯誤和索引通知引發異常： mysqli_report(MYSQLI_REPORT_STRICT ^ MYSQLI_REPORT_INDEX); 如果啟用 MYSQLI_REPORT_STRICT（或 MYSQLI_REPORT_ALL），則必須確保將所有 mysqli 代碼放在 try{} 塊中，並且捕獲 mysql_sql_exception。 否則，由於未捕獲的異常，PHP 會拋出致命錯誤。
```

## 示例：mysqli_sql_exception 異常處理
• 異常處理示例：
```
01 mysqli_report(MYSQLI_REPORT_ALL); 
02 try {
03 $sql = "SELECT a FROM nothing";
04 echo "Running $ statement: $sql\n";
05 $res = $mysqli->query($sql);
06 echo "This line is never executed.\n";
07 }
08 catch(mysqli_sql_exception $e) {
09 echo "Error number: " . $e->getCode() . "\n";
10 echo "Error message: " . $e->getMessage() . "\n";
11 }
```
• 輸出：
```
Running statement: SELECT a FROM nothing
Error number: 1146
Error message: Table 'world.nothing' doesn't exist
```
```
要使用 mysqli_sql_exception 啟用異常處理，您必須在 mysqli 驅動程序中啟用報告，如幻燈片示例中代碼的第 1 行所示。
第 6 行永遠不會執行：mysqli 在發生錯誤的地方拋出異常，
在執行查詢的代碼行（第 5 行），並立即將控制權交給第 8 行的 catch 塊
```

## 連接器/Python：mysql.connector.Error 類
• mysql.connector.errors 模塊為連接器/Python 引發的錯誤和警告定義了大多數異常類。
– 當您導入 mysql.connector 時，大多數都可用。
• 錯誤模塊中所有錯誤的基類是錯誤模塊中所有錯誤的基類是錯誤。
– 所有子類都有 errno、sqlstate 和 msg 屬性。
• Python 將 SQLSTATE 映射到適當的特定於錯誤的類。
– 示例：DataError、ProgrammingError – 默認為 DatabaseError DatabaseError。
• errorcode 模塊使 MySQL 服務器和客戶端錯誤代碼可用作類屬性以提高可讀性：
```
>>> from mysql.connector import errorcode
>>> errorcode.ER_BAD_TABLE_ERROR
1051
```
errors 模塊中的所有類都繼承自 errors.Error 類，後者又繼承自 Python StandardError 類。 檢查類的屬性以確定錯誤的確切性質。 例如
![[Pasted image 20211219030702.png]]
```
注意：您可以在連接器/Python 開發人員指南 API 參考中查看 SQLSTATE/錯誤類映射的完整列表：http://dev.mysql.com/doc/connector-python/en/connector-python-api-errors.html。
```

## 示例：連接器/Python 錯誤處理
• 示例代碼
```
01 import mysql.connector
02 from mysql.connector import errorcode
03 try:
04 cnx = mysql connector connect mysql.connector.connect(user= mark ' ', password= password= secret 'secret', 
database='nosuchdb')
05 except mysql.connector.Error as err:
06 if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
07 print("Check your user name and password")
08 elif err.errno == errorcode.ER_BAD_DB_ERROR:
09 print("Database does not exist")
10 else:
11 print("There is an error: {0}".format(err)):
p { }
12 else:
13 cnx.close()
```
• 輸出:
```
Database does not exist
```
```
在幻燈片的代碼示例中，用戶嘗試連接到不存在的數據庫 (nosuchdb)。
• 在第 1 行，程序導入 mysql.connector 類以訪問核心
連接器/Python 功能和許多錯誤類。
• 在第 2 行，程序從 mysql.connector 導入 errorcode 模塊，以訪問以不同類型的錯誤命名的類屬性。 使用此模塊使連接器/Python 代碼更易於閱讀。
• 在第 4 行，程序嘗試連接到 try 塊內的數據庫並失敗。
控制傳遞到第 5 行中的 except 塊。• 在第6 行，程序檢查傳遞給except 塊的Error 對象。 這個 except 塊捕獲拋出給它的任何連接器/Python 錯誤類。 它將 Error 對象的 errno 屬性與表示訪問被拒絕錯誤（MySQL 錯誤號 1045）的 errcode 屬性進行比較。 沒有匹配項，控制權傳遞到第 8 行。
• 在第 8 行，程序確定 Error 對象的 errno 屬性與 ER_BAD_DB_ERROR 的代碼（MySQL 錯誤號 1049）之間是否匹配。 因為程序試圖連接到一個不存在的數據庫，這是引發的錯誤。
• 在第 11 行，程序向用戶報告錯誤並退出程序。
```

## 總結 
在本課中，您應該已經學會瞭如何： 
• 設置 SQL 模式以影響錯誤輸出
• 解釋錯誤消息 
• 使用 SHOW WARNINGS 和 SHOW ERRORS 語句
• 檢查 MySQL 診斷信息 
• 使用 perror 實用程序檢索錯誤詳細信息
• 處理 使用連接器編碼時出錯