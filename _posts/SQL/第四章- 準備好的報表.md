## 完成本課程後，您應該能夠：
## 目標完成本課程後，您應該能夠：
完成本課程後，您應該能夠：
• 列出使用準備好的語句的原因及其限制
• 描述 SQL 注入以及準備好的語句如何幫助保護它
• 使用 mysql 命令行客戶端準備、執行和取消分配準備好的語句
• 在帶有連接器的代碼中使用準備好的語句

## 議程
• 使用準備好的語句的原因
• 用戶定義的變量
• 準備、執行和釋放準備好的語句
• 將準備好的語句與連接器一起使用

## 為什麼要使用準備好的語句？
• 提高查詢性能。 您準備一個語句並執行多次，每次使用不同的數據值。
– 服務器僅解析語句一次，當它準備語句時，為該語句創建新協議，為該語句創建新協議。
– 服務器僅解析語句一次，當它準備語句時，為該語句創建新協議，為該語句創建新協議。
— 減少服務器 CPU 開銷 
— 與單獨發送每個語句相比，減少了服務器和客戶端之間的網絡流量
• 為確保數據類型在 SQL 語句中正確引用
• 避免 SQL 注入通常，您使用連接器從程序代碼準備和執行語句。
但是，為了幫助測試和調試，您可以從 mysql 命令行客戶端中定義和執行準備好的語句。
當服務器準備一條語句時，它會為該語句創建一個協議。 通常，客戶端將 SQL 語句與值一起傳遞，這些值由服務器從原始文本字符串中解析出來。 預準備語句的協議將值與語句的其餘部分分開，並提供一種二進制機制來傳輸值。 這比在字符串之間進行轉換更有效。
準備好的語句還有助於防止一種稱為 SQL 注入的攻擊形式。 惡意的 SQL 惡意用戶可以將 SQL 命令插入到需要值的應用程序中。 準備好的語句將 SQL 命令與值分開，並防止將值解釋為 SQL 語句。
```
通常，您使用連接器從程序代碼準備和執行語句。
但是，為了幫助測試和調試，您可以從 mysql 命令行客戶端中定義和執行準備好的語句。
當服務器準備一條語句時，它會為該語句創建一個協議。 通常，客戶端將 SQL 語句與值一起傳遞，這些值由服務器從原始文本字符串中解析出來。 預準備語句的協議將值與語句的其餘部分分開，並提供一種二進制機制來傳輸值。 這比在字符串之間進行轉換更有效。
準備好的語句還有助於防止一種稱為 SQL 注入的攻擊形式。 惡意的 SQL 惡意用戶可以將 SQL 命令插入到需要值的應用程序中。 準備好的語句將 SQL 命令與值分開，並防止將值解釋為 SQL 語句。
```

## 準備報表的局限性
• 不能嵌套準備好的語句。
– 您要準備的語句不能包含 PREPARE、EXECUTE 或 DEALLOCATE PREPARE。
• 只能準備單個語句，不能準備多語句。
– 多語句由單個字符串中的多個語句組成，由終止符分隔。
• 您不能準備某些類型的報表。 例如： – LOCK TABLES/UNLOCK TABLES, LOAD DATA/LOAD TABLE, ALTER VIEW
– 診斷語句（診斷語句（SHOW ERRORS/SHOW WARNINGS SHOW ERRORS/SHOW WARNINGS）
• 不能準備包含動態游標聲明的語句。
– 這是因為 MySQL 在創建游標時會檢查游標語法/語句

```
MySQL 不允許您準備每種類型的 SQL 語句。 允許的語句列表類似於存儲例程中允許的語句。
MySQL 5.7.2及更高版本，不能按照SQL標準的要求準備診斷語句。 診斷語句包括：
• SHOW ERRORS/WARNINGS 
• SIGNAL/RESIGNAL 
• GET DIAGNOSTICS 
• 任何引用warning_count 或error_count 系統變量的語句
注意 
• 有關準備好的語句中允許的 SQL 語句的完整列表，請參閱：https://dev.mysql.com/doc/mysql/en/sql-syntax-prepared-statements.html。
• 本課程涵蓋題為“存儲例程”的課程中的存儲例程。
```

## SQL注入
SQL 注入是一種技術，惡意用戶可以通過基於表單的輸入將 SQL 命令注入到 Web 應用程序中。
示例： 
• 服務器代碼：
```
parse_str($_SERVER['QUERY_STRING']);
$sql = "SELECT * FROM Users WHERE UserId = " + $UserId;
$rs = $mysqli->query(sql);

```
• 表格輸入：
![[Pasted image 20211217092550.png]]
• 結果 SQL：
```
SELECT * FROM Users WHERE UserId = 11000 OR 1=1;
SELECT * FROM Users WHERE UserId = 22; DROP TABLE tb11;
```
```
幻燈片中的示例顯示了當 SQL 不使用參數化查詢（如預準備語句啟用的查詢）時，惡意用戶如何將可能有害的 SQL 代碼注入到基於 Web 的表單中。
在此 Web 應用程序中，用戶在 HTML 表單中的用戶 ID 文本框中輸入一個值。 瀏覽器將表單提交給服務器。  Web 應用程序檢索輸入的值，將其存儲在名為 txtUserID 的變量中，將其附加到包含 SQL 語句的字符串，然後執行查詢。
示例 1：用戶在用戶 ID 文本框中輸入 11000 OR 1=1。 當這個文本被附加到 SQL 語句中時，因為 1=1 總是為真，MySQL 服務器返回所有記錄。如果記錄是一個真正的安全風險。 如果用戶表包含密碼數據表包含密碼數據，則這是一個真正的安全風險。
例2：用戶輸入22； 刪除表 tbl1; 添加分號允許將兩條 SQL 語句作為批處理執行，其中第二條會刪除 tbl1 表並可能導致災難性的數據丟失。
準備好的語句有助於防止 SQL 注入，因為要插入 SQL 查詢的值會獨立於查詢本身發送到 MySQL 服務器。 這意味著這些值總是被解釋為數據而不是 SQL 代碼值總是被解釋為數據而不是 SQL 代碼。
```
## 用戶定義的變量
您可以將值存儲在用戶定義的變量（也稱為用戶變量）中，然後從其他語句（包括準備好的語句）中引用它。 用戶定義的變量：
• 看起來像：@var_name
• 通過使用 SET stt 語句分配一個值：`
```
SET @var_name = expr [, @var_name = expr] ...
```
– 該值必須是整數、實數、字符串或空類型。
– 如果該值來自結果集，則 SET 語句將該值視為字符串。
• 屬於創建它們的連接。 其他連接無法訪問它們。
– 當客戶端斷開連接時，服務器會釋放連接期間創建的所有變量。
```
用戶變量具有與表名和列名相同的命名條件。 變量名由當前字符集中的字母數字字符以及字符“.”、“_”和“$”組成。 要在變量名稱中使用其他字符，請包括整個名稱作為 版權所有 © 2017，Oracle 和/或其附屬公司。 版權所有。
引號內的字符串或標識符。 例如，@'my-var'、@"my-var" 或 @`my-var`。
對於 SET，使用 = 或 := 作為賦值運算符。 將值（文字或表達式）分配給變量時，該值的數據類型必須是整數、實數、字符串或 NULL。
但是，如果變量的值來自結果集，則 SET 語句將該值視為字符串。
如果將字符串分配給用戶變量，則該變量使用與字符串相同的字符集和排序規則。 用戶變量的可強制性是隱含的。  （Coercibility 定義在單個表達式中的值之間的排序規則衝突的情況下轉換哪個值的排序規則。）當您插入或更新具有與表中定義的排序規則不同的排序規則的字符串時，這與表列值的工作方式相同
```

## 準備聲明
• 使用 PREPARE 準備語句
```
PREPARE statement_name FROM preparable_statement
```
– statement_name 是一個標識符，因此您可以稍後參考該語句。 它不區分大小寫。
– preparable 語句 preparable_statement 要么是字符串文字，要么用戶要么是字符串文字，要么是包含 SQL 語句文本的用戶變量。
- 使用 ？ 字符作為參數標記，指示執行語句時數據值將在哪裡綁定到語句。
— 僅使用參數標記來表示數據值，而不是 SQL 關鍵字、表或列名稱等。
— 不要將參數標記括在引號中，即使您需要一個字符串值
• 準備好的語句僅存在於創建它的會話範圍內。
```
您可以準備完整的陳述或不完整的陳述。 完整語句包含執行語句所需的所有 SQL 代碼和值。 不完整的語句包含在準備時未知的數據值的佔位符。 
佔位符由問號“?”字符表示。 執行語句時，必須提供特定的數據值，語句中的每個參數一個。 服務器用您提供的數據值替換標記以完成語句。 每次執行語句時都可以使用不同的值。
如果您嘗試準備一個與已經存在的語句同名的語句，MySQL 會在準備新語句之前釋放當前語句。 如果由於任何原因無法準備新語句，MySQL 引發錯誤並且由於任何原因沒有重新準備，MySQL 會引發錯誤並且不會重新創建先前的 create 先前語句。
準備好的語句只存在於創建它的會話中，並且不可用於其他客戶端連接。 如果會話因任何原因結束，其準備好的語句將自動解除分配。 這可能會在存儲例程的上下文中導致不需要的副作用。
注意：本課程在“存儲例程”課程中介紹了在存儲例程中使用準備好的語句。
```

## 執行準備好的語句
服務器準備好語句後，您就可以執行它了。
• 如果語句包含任何問號“？” 參數標記，您必須提供一個用戶變量，該變量包含每個標記的兼容數據類型的值。
• 要執行準備好的語句，請發出EXECUTE...USING 語句。 例如
```
SET @var1 = 'USA';
EXECUTE my_prepared_stmt USING @var1;
SET @var2 = 'GBR';
EXECUTE my prepared stmt USING @var2;
```
• 如果語句不包含參數標記，則省略 USING 子句。
```
USING 子句必須命名與語句中的參數標記一樣多的值，並且值的替換順序與它們列出的順序相同。
如果在準備好的語句中引用一個尚未設置的值，則其值為 NULL
```

## 釋放準備好的語句
準備好的語句佔用內存空間。 要釋放該空間，您必須釋放準備好的語句。
• 當您執行以下操作時，服務器會自動取消分配準備好的語句： 
– 重新定義另一個同名的準備好的語句 – 關閉與服務器的連接 
• 您可以使用 DEALLOCATE PREPARE 顯式取消分配準備好的語句：
```
mysql> DEALLOCATE PREPARE my_prepared_stmt;
Q O 0 ff d (# ## )
```
準備好的語句示例：SQL

## 準備好的語句示例：SQL
mysql> PREPARE my_stmt FROM
-> 'SELECT COUNT(*) FROM CountryLanguage
-> WHERE CountryCode= ?';
Query OK, 0 rows affected (#.## sec)
Statement prepared
mysql> SET @code 'ESP'; SET @code = 'ESP';
mysql> EXECUTE my_stmt USING @code;
Query OK, 0 rows affected (#.## sec)
+----------+
| COUNT(*) |
+----------+
|4                 
+----------+
1 row in set (#.## sec)
mysql> DEALLOCATE PREPARE my_stmt;
Query OK, 0 rows affected (#.## sec)
```
幻燈片中的示例準備了一個語句，該語句確定給定國家/地區使用的語言數量，執行它（使用用戶變量），然後釋放它。 您可以多次執行準備好的語句，為每個 @code 指定一個新值
以下示例演示了使用多個參數標記並使用不同的值多次執行準備好的語句以返回指定國家和地區內的城市人口：

mysql> PREPARE distpop FROM
-> 'SELECT Name, Population FROM City
'> WHERE CountryCode = ? AND District = ?';
Query OK, 0 rows affected (0.00 sec)
Statement prepared
mysql> SET @code = 'NLD';
Query OK, 0 rows affected (0.00 sec)
mysql> SET @dist = 'Zuid-Holland';
Query OK, 0 rows affected (0.00 sec)
mysql> EXECUTE distpop USING @code, @dist;
+------------+------------+
| Name | Population |
+------------+------------+
| Rotterdam | 593321 | | Rotterdam | 593321 |
| Haag | 440900 |
| Dordrecht | 119811 |
| Leiden | 117196 |
| Zoetermeer | 110214 |
| Delft | 95268 |
+------------+------------+
6 rows in set (0.05 sec)
mysql> SET @code = 'BGD';
Query OK, 0 rows affected (0.00 sec)
mysql> SET @dist = 'Rajshahi';
Query OK, 0 rows affected (0.00 sec)
mysql> EXECUTE distpop USING @code, @dist;
+-----------+------------+
| Name | Population |
+-----------+------------+
| Rajshahi | 294056 |
| Rangpur | 191398 |
| Nawabganj | 130577 |
| Dinajpur | 127815 |
| Bogra | 120170 | | 120170 |
| Pabna | 103277 |
| Naogaon | 101266 |
| Sirajganj | 99669 |
| Saidpur | 96777 |
+-----------+------------+
9 rows in set (0.06 sec)
mysql> SET @code 'IDN'; mysql> SET @code = 'IDN';
Query OK, 0 rows affected (0.00 sec)
mysql> SET @dist = 'Jambi';
Query OK, 0 rows affected (0.00 sec)
mysql> EXECUTE distpop USING @code, @dist;
+-------+------------+
|| | Name | Population |
+-------+------------+
| Jambi | 385201 |
+-------+------------+
1 row in set (0.00 sec)
```

## 使用連接器準備語句
準備好的語句利用了使用連接器時可用的二進制協議。
• 通過連接器使用預準備語句比使用來自 mysql 的相同預準備語句更有效。
• 每個連接器都提供一個API 來使用準備好的語句。
例如，C API 提供：
– mysql_stmt_init() 
– mysql_stmt_prepare() 
– mysql_stmt_bind_param() 
– mysql_stmt_bind_result()
– mysql_stmt_execute() 
– mysql_stmt_fetch()
```
儘管您可以在 mysql 命令行客戶端中使用 SQL 準備和執行語句，但是當您通過連接器使用它們時，您將從準備好的語句中獲得最大的好處。
使用準備好的語句 API（應用程序編程接口）調用時，您必須遵循與在 mysql 客戶端中使用 SQL 準備語句時相同的規則。
例如，您不能使用 mysql_stmt_prepare() C API 函數來準備 PREPARE、EXECUTE 或 DEALLOCATE PREPARE SQL 語句。
不同編程語言的連接器提供了它們自己的函數和數據結構，允許您準備和執行語句。 該幻燈片向您展示了 C API 中提供的一些函數。 顯示的函數允許您： 
• 為準備好的語句創建容器 (mysql_stmt_init()) 
• 通過提供 SQL 字符串準備語句 (mysql_stmt_prepare()) 
• 傳遞參數和結果的容器（mysql_stmt_bind_param() 和 mysql_stmt_bind_result  ()) 
• 執行語句 (mysql_stmt_execute()) 
• 一次選擇一行結果 (mysql_stmt_fetch())
```

使用 PHP/PDO 準備語句
• 要使用 PDO_MySQL 在 PHP 中準備語句，您必須： 
– 創建帶有命名佔位符（或問號）的 SQL 語句，以表示每次執行時都會改變的值：
```
$sql = "INSERT INTO MyTable VALUES (col1, col2, col3) " .
"VALUES (:col1_value, :col2_value, :col3_value)";
```
– 從連接對象創建一個語句對象：
```
$stmt = $dbh->prepare($sql);
```
– 使用以下語法綁定包含命名佔位符值的變量：
```
$stmt->bindParam(':placeholder', $variable)
```
• 要執行準備好的語句： 
– 為綁定變量賦值 
– 調用 $stmt->execute()
```
要在 PHP/PDO 中創建準備好的語句，請使用佔位符為每次執行時會更改的值編寫 SQL。 幻燈片中的示例使用“命名”佔位符而不是問號來執行此操作。 這種方法是首選，
更容易閱讀。 準備好語句後，通過使用語句對象的 bindParam() 方法為每個佔位符設置值來準備執行。
使用語句對象的 execute() 方法執行準備好的語句，無論該語句是否是返回行的查詢。
執行語句並讀取其返回值後，將新值分配給佔位符並重新執行準備好的語句，而無需再次準備它。 當你完成準備好的語句時，用完成的準備好的語句關閉它，用 $tt s m ->cl () ose 關閉它
```

## 示例：使用 PHP/PDO 準備語句
```
01 <?php
02 $dbh = new PDO (...);
03 $sql = "INSERT INTO CountryLanguage " .
04 (CountryCode, Language, IsOfficial, Percentage) " . 
05 "VALUES (:code, :language, :official, :pct)";
06 $stmt = $dbh->prepare($sql);
07 $stmt->bindParam(':code', $code);
08 $stmt->bindParam(':language', $language);
09 $stmt->bindParam( , $ ); ':official', $official);
10 $stmt->bindParam(':pct', $pct);
11
12 $code = "ABW";
13 $language = "Klingon";
14 $official = "F";
15 $pct = 0.9;
16 $stmt->execute();
17
18 $code = "AFG";
19 $language "Esperanto" $language = "Esperanto";
20 $official = 'F';
21 $pct = 1.2;
22 $stmt->execute();
23
24 $stmt->close();
25 ...
26 ?>
```
```
幻燈片中的示例將新記錄插入到世界數據庫的 CountryLanguage 表中。
• 在第 2 行，程序連接到服務器並創建一個連接對象，標識為$dbh.
• 在第 3 到 5 行中，程序創建了一個由 $sql 標識的 SQL 語句字符串，其中插入值的命名佔位符為“:identifier”格式 • 在第 6 行中，程序通過調用從提供的 SQL 字符串準備一個語句 連接對象的 prepare() 方法。
• 在第 7 到 10 行，程序調用語句對象的 bindParam() 方法將變量綁定到命名參數。
• 在第 12 到 15 行，程序為綁定到語句的變量賦值。
• 在第 16 行，程序調用語句對象的 execute() 方法來執行準備好的語句，並為其分配值。
• 在第 18 至 21 行，程序為綁定變量分配新值並再次執行準備好的語句。
• 在第 24 行，程序關閉語句對象，釋放準備好的語句，並在腳本終止之前執行任何其他所需的清理工作。
```

## 使用連接器/J 準備語句
• 使用 Connector/J 準備語句： 
– 創建一個 Connection 對象 
– 創建一個 PreparedStatement 對象 
• 執行準備好的語句： 
– 為準備好的語句中的所有參數標記賦值 
– 使用特定於數據類型的 setter 方法：setXXX(parameter_number  , value) 
— 要分配空值，請使用： setNull setNull(parameter number parameter_number, data type data_type) — 其中 data_type 是 java.sql.Types.CHAR 或 java.sql.Types.INTEGER 等 java JDBC 類型 
– 調用 適當的執行方法
——如果語句返回結果集，請使用 executeQuery()。
— 否則，使用 executeUpdate()
```
Connector/J 通過在 java.sql 包中實現 PreparedStatement 接口來支持服務器端準備好的語句。 通過在 Connection 實例上使用 prepareStatement() 方法創建 PreparedStatement。
使用 PreparedStatement 對象的 setXXX() 方法將值綁定到參數標記，其中 XXX 是要綁定的值的數據類型。 例如： • setString(1, "Bob Smith"); 將字符串值“Bob Smith”分配給第一個參數標記。
• setInt(2, 353); 將整數值 353 分配給第二個參數標記。
要分配空值，請調用 setNull() 並傳入要設置的參數標記的位置及其代表的 JDBC 數據類型。 例如： • setNull(3, java.sql.Types.INTEGER); 為第三個參數標記分配一個空值，它是一個整數
```

## 示例：使用 Connector/J 準備語句
```
01 Connection c = DriverManager.getConnection(...);
02 String sql = "INSERT INTO CountryLanguage " + "
03 "(CountryCode, Language, IsOfficial, Percentage) " + 
04 "VALUES (?,?,?,?);
05 PreparedStatement ps = c.prepareStatement(sql); 
06 ps.setString(1, "ABW"); 
07 ps setString ps.setString(2, "Klingon Klingon");
08 ps.setString(3, "F");
09 ps.setDouble(4, 0.9);
10 ps.executeUpdate(); 
11
12 ps.setString(1, "AFG"); 
13 ps.setString(2, "Esperanto");
14 p g s.setString(3, ; "F")
15 ps.setDouble(4, 1.2);
16 ps.executeUpdate(); 
17
18 ps.close();
```
```
幻燈片中的示例將新行插入到 world 數據庫的 CountryLanguage 表中。  Connection、PreparedStatement 和 ResultSet 是標準 java.sql 包中的接口。 連接器/J 類實現這些接口。
• 在第 1 行，程序創建到數據庫的連接並將返回的 java.sql.Connection 對象存儲在變量 c 中。
• 在第 2 行到第 4 行，程序將要準備的 SQL 語句存儲在名為 sql 的字符串值中，並帶有參數標記（用“?”表示），用於表示程序必須為每次執行語句提供的值。
• 在第5 行，程序調用Connection 的prepareStatement() 方法來創建com.mysql .jdbc.PreparedStatemen 的實例並將其分配給變量ps。 此時，您有一個準備好的語句，您可以通過為 SQL 語句字符串中的每個參數標記指定值來調用該語句。
• 在第 6 行到第 8 行，程序調用 PreparedStatement 對象的 setString() 方法將字符串值分配給存儲在變量 sql 中的 SQL 語句字符串中的第一個參數標記。  setString() 方法將數字 1 用作其參數以標識第一個參數標記，並使用字符串 y 來指定其值。
• 在第 9 行，程序調用 PreparedStatement 對象的 setDouble() 方法為第四個參數標記分配一個浮點值，它對應於
• 在第 9 行，程序調用 PreparedStatement 對象的 setDouble() 方法為第四個參數標記分配一個浮點值，它對應於 CountryLanguage 表的 Percentage 列。
• 在第 10 行， PreparedStatement 對象的 executeUpdate() 方法執行準備好的語句並向包含提供的值的表中添加一個新行。 如果這是一個返回結果集的查詢，您將改用 executeQuery() 方法並將結果存儲在 ResultSet 對像中。
• 在第 12 到 15 行中，程序將新值應用於 SQL 語句中的參數標記。
• 在第 16 行，調用 executeUpdate() 使用提供的新值重新執行語句。
• 在第 18 行，程序釋放 PreparedStatement 對象
```
## 使用連接器/Python 準備語句
要使用連接器/Python 處理準備好的語句： 
• 創建游標，傳入參數 Prepared=True 
– 返回 MySQLCursorPrepared 對象
```
cnx = mysql.connector.connect(...)
csr = cnx.cursor(prepared=True)
```
• 使用參數標記為您將為每次執行提供的值構建 SQL 語句字符串：
```
sql = "INSERT INTO MyTable (col1,col2,col3)" +
"VALUES (%s, %s, %s)"
```
• 執行語句，為每個參數提供值：
csr.execute(sql, (val1, val2, val3));
– 第一次調用 execute() 準備語句。
– 對 execute() 的後續調用跳過準備階段。
```
SQL 語句中的 %s 符號是參數標記，它將被您為語句的每次執行提供的值替換。 不要在參數標記周圍加上引號。
第一次調用 execute() 時，它會為語句創建一個新協議。 對 execute() 的後續調用更快，因為它們不必解析語句並改為使用新協議。
```

## 示例：使用連接器/Python 準備語句
```
01 cnx = mysql.connector.connect(...);
02 sql = "INSERT INTO CountryLanguage " + "
03 "(CountryCode, Language, IsOffical, Percentage) " + 
04 "VALUES (%s,%s,%s,%s);
05 crs = cnx.cursor(prepared=True); 
06
07 crs.execute("ABW", "Kling , on" "F", ; 0.9)
08 crs.execute("AFG", "Esperanto","F", 1.2);
09
10 crs.close();
11 cnx.commit();
```
```
幻燈片中的示例向 world 數據庫中的 CountryLanguage 表添加了新行。
• 在第 1 行，程序創建與數據庫的連接並存儲返回的變量 cnx 中的連接對象
• 在第 2 到 4 行中，程序將要準備的 SQL 語句存儲在名為 sql 的字符串值中，並帶有參數標記（用 %s 表示），用於程序必須為語句的每次執行提供的值。
• 在第5 行，程序創建游標，傳入參數prepared=True 以指示MySQL 服務器必須為此語句創建新協議。
• 在第 7 行，程序執行語句，為每個參數標記傳遞合適的值。 第一次執行準備語句。
• 在第 8 行，程序使用新值再次執行語句。 該語句的執行會跳過解析階段，而是使用新協議。
• 在第 10 行，程序釋放準備好的語句。
• 在第 11 行，程序提交對數據庫的更改
```

總結 在本課中，您應該已經學會瞭如何：
• 列出使用預處理語句的原因及其限制 
• 描述 SQL 注入以及預處理語句如何幫助防止注入 
• 使用 mysql 準備、執行和釋放預處理語句 命令行客戶端 
• 在帶有連接器的代碼中使用準備好的語句